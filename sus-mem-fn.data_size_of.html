<!DOCTYPE html>
<html>
  <head>
    <meta name="generator" content="subdoc"></meta>
    <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
    <meta property="og:type" content="website"></meta>
    <meta property="og:site_name" content="Subspace"></meta>
    <title>sus::mem::data_size_of - Subspace</title>
    <meta property="og:title" content="sus::mem::data_size_of - Subspace"></meta>
    <meta name="description" content="Returns the data size of the type T."></meta>
    <meta property="og:description" content="Returns the data size of the type T."></meta>
    <script src="https://unpkg.com/lunr/lunr.js"></script>
    <script src="./search_db.js"></script>
    <script>
      
        // Delayed loading of whatever was in the search box.
        var searchDelayLoad;

        // The search box's dynamic behaviour.
        document.addEventListener("keyup", e => {
          if (e.key === 's') {
            document.querySelector('.search-input').focus();
          }
          if (e.key === 'Escape') {
            document.querySelector('.search-input').blur();
            navigateToSearch(null);
            e.preventDefault();
          }
        });
        function navigateToSearch(query) {
          window.clearTimeout(searchDelayLoad);
          searchDelayLoad = null;

          let without_search =
              window.location.origin + window.location.pathname;
          if (query) {
            window.history.replaceState(null, "",
              without_search + "?" + `search=${query}`);
          } else {
            window.history.replaceState(null, "", without_search);
          }
          maybeShowSearchResults();
        }
        addEventListener("load", event => {
          document.querySelector(".search-input").oninput = (e) => {
            window.clearTimeout(searchDelayLoad);
            searchDelayLoad = window.setTimeout(() => {
              navigateToSearch(e.target.value);
            }, 1000);
          };
          document.querySelector(".search-input").onkeypress = (e) => {
            if (e.key == "Enter") {
              navigateToSearch(e.target.value);
              e.preventDefault();
            }
          };
          var searchPlaceholder;
          document.querySelector(".search-input").onfocus = (e) => {
            searchPlaceholder = e.target.placeholder;
            e.target.placeholder = "Type your search here.";
            navigateToSearch(e.target.value);
          };
          document.querySelector(".search-input").onblur = (e) => {
            e.target.placeholder = searchPlaceholder;
            searchPlaceholder = null;
          };
        });

        // Show or hide any DOM element.
        function showHide(selector, show) {
          if (show)
            document.querySelector(selector).classList.remove("hidden");
          else
            document.querySelector(selector).classList.add("hidden");
        }

        function searchQuery() {
          const params = new Proxy(
            new URLSearchParams(window.location.search), {
              get: (searchParams, prop) => searchParams.get(prop),
            }
          );
          return params.search;
        }

        // Showing search results.
        async function populateSearchResults(loaded) {
          const search_db = loaded.search_db;
          const idx = loaded.idx;

          // lunrjs treats `:` specially and `::` breaks the query syntax, so
          // just split into two words.
          const query = searchQuery().split("::").join(" ");
          let content = '';
          try {
            const results = idx.search(query);
            for (r of results) {
              const item = search_db[r.ref];

              const type = item.type;
              const url = item.url;
              const name = item.name;
              const full_name = item.full_name;
              const summmary = item.summary ? item.summary : "";

              content += `\
                <a class="search-results-link" href="${url}">
                  <span class="search-results-type"><span>${type}</span></span>\
                  <span class="search-results-name"><span>${full_name}</span></span>\
                  <span class="search-results-summary"><span>${summmary}</span></span>\
                </a>\
                `
            }
          } catch (err) {
            content +=
                `<div class="search-error">Search error: ${err.message}</div>`;
          }

          let content_elem = document.querySelector(".search-results-content");
          content_elem.innerHTML = content;

          let header_elem = document.querySelector(".search-results-header");
          header_elem.innerText = "Search results";
        }

        var cache_idx;

        // Searching via https://lunrjs.com.
        //
        // Load the JSON search database, which will be turned into a search
        // index. Returns an object with two fields:
        // - search_db: the contents of the search.json file.
        // - idx: the lunr search index.
        //   Documented at https://lunrjs.com/docs/lunr.Index.html.
        async function loadSearchIndex() {
          // This is not widely supported yet (not on Safari), so instead we
          // turned the json file into a js file that sets a global variable. :|
          //async function load_search_db() {
          //  let x = await import('./search.json', {
          //    with: {type: 'json'}
          //  });
          //  return x.default;
          //}

          async function load_idx(search_db) {
            let idx = lunr(function () {
              this.ref('index');
              this.field('name', {
                'boost': 2
              });
              this.field('full_name', {
                'boost': 2
              });
              this.field('split_name', {
                'boost': 0.5
              });
              this.field('summary', {
                'boost': 1
              });
              this.field('full_description', {
                'boost': 0.75
              });

              // No stemming?
              // this.pipeline = new lunr.Pipeline();

              this.use(builder => {
                function splitColons(token) {
                  return token.toString().split("::").map(str => {
                    return token.clone().update(() => { return str })
                  })
                }
                lunr.Pipeline.registerFunction(splitColons, 'splitColons')
                builder.searchPipeline.before(lunr.stemmer, splitColons)
              });

              search_db.forEach(item => {
                this.add(item, {
                  'boost': item.weight ? Number(item.weight) : 1
                })
              }, this);
            });
            let out = {};
            out.search_db = search_db;
            out.idx = idx;
            return out;
          };

          if (!cache_idx) {
            cache_idx = await load_idx(g_search_db);
          }
          return cache_idx;
        }

        // If there's a search query, hide the other content and asynchronously
        // show the search results. Otherwise, hide search content and show the
        // rest immediately.
        function maybeShowSearchResults() {
          const query = searchQuery();
          if (query) {
            showHide(".main-content", false);

            let input = document.querySelector(".search-input");
            input.value = query;

            let header_elem = document.querySelector(".search-results-header");
            header_elem.innerText = "Loading search results...";

            let content_ele = document.querySelector(".search-results-content");
            content_ele.innerText = "";

            loadSearchIndex().then(populateSearchResults)
          } else {
            showHide(".main-content", true);

            let header_elem = document.querySelector(".search-results-header");
            header_elem.innerText = "";

            let content_ele = document.querySelector(".search-results-content");
            content_ele.innerText = "";
          }
        }

        
    </script>
    <link rel="stylesheet" href="subdoc-test-style.css">
    <link rel="icon" type="image/png" href="logo.png">
    <link rel="alternate icon" type="image/png" href="logo32.png">
    <link rel="alternate icon" type="image/png" href="logo16.png">
    <meta property="og:image" content="logo.png"></meta>
  </head>

  <body>
    <nav class="topbar">
      <button class="sidebar-menu-button" onclick="let e = document.getElementsByClassName('sidebar')[0];e.classList.toggle('shown');">
        â˜°
      </button>
      <a class="topbar-logo-link" href="index.html"><div class="topbar-logo-border">
          <img class="topbar-logo" src="logo.png"></img>
        </div></a>
      <span class="topbar-text-area">
        <span class="topbar-title">
          <a href="#">data_size_of</a>
        </span>
      </span>
    </nav>
    <nav class="sidebar">
      <a class="sidebar-logo-link" href="index.html"><div class="sidebar-logo-border">
          <img class="sidebar-logo" src="logo.png"></img>
        </div></a>
      <div class="sidebar-pretitle sidebar-text">
        function
      </div>
      <div class="sidebar-title sidebar-text">
        <a href="#">data_size_of</a>
      </div>
      <div class="sidebar-subtitle sidebar-text">
      </div>
      <div class="sidebar-links sidebar-text">
        <ul>
        </ul>
      </div>
    </nav>
    <main>
      <nav class="search-nav">
        <form class="search-form">
          <input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press 'S' to search...">
          </input>
        </form>
      </nav>
      <section class="search-results">
        <h1 class="search-results-header">
        </h1>
        <div class="search-results-content">
        </div>
      </section>
      <section class="main-content">
        <script>maybeShowSearchResults()</script>
        <div class="function">
          <div class="section overview">
            <h1 class="section-header">
              <span>
                Function
              </span>
              <a class="project-name" href="index.html">Subspace</a>
              <span class="namespace-dots">::</span>
              <a class="namespace-name" href="namespace.sus.html">sus</a>
              <span class="namespace-dots">::</span>
              <a class="namespace-name" href="sus-namespace.mem.html">mem</a>
              <span class="namespace-dots">::</span>
              <a class="function-name" href="#">data_size_of</a>
            </h1>
            <div class="overload-set">
              <div class="overload">
                <div class="function-signature"><div class="src rightside"><a href="https://github.com/chromium/subspace/blob/main/sus/mem/size_of.h#L125">source</a></div><div class="template">template &lt;class T&gt;</div><span class="function-auto">auto</span> <a class="function-name" href="#">data_size_of</a>() -&gt; size_t<div class="requires">
                    <span class="requires-keyword keyword">
                      requires
                    </span>
                    <div class="requires-constraint"><pre class="requires-constraint-line">!std::is_reference_v&lt;T&gt;</pre></div>
                  </div></div>
              </div>
            </div>
            <div class="description long">
              <p>Returns the data size of the type <code>T</code>.</p>
<p>This is the number of bytes for the type excluding any tail padding, which
is the number of bytes that can be memcpy'd into the type without
potentially overwriting other objects. This is due to the fact that other
objects can be placed inside tail padding of an object in some scenarios.</p>
<p>To get the size of an object including tail padding, such as to know the
storage taken in an array or as a stack variable, use
<a href="sus-mem-fn.size_of.html"><code>size_of</code></a>.</p>
<p>Returns <code>size_t(-1)</code> for types where the tail padding can not be determined.
In particular this is the case for union types unless and until compilers
provide additional support to determine the maximum data size of all
union members.</p>
<p>From @ssbr:</p>
<p>If type <code>T</code> has padding at its end, such as:</p>
<pre><code><span class="keyword">class</span> T <span class="punct">{</span> i64 a<span class="punct">;</span> i32 b<span class="punct">;</span> <span class="punct">}</span><span class="punct">;</span>
</code></pre>
<p>Then there are two ways for another type to place a field inside the padding
adjacent to <code>b</code> and inside area allocated for
<a href="sus-mem-fn.size_of.html"><code>size_of&lt;T&gt;()</code></a>:</p>
<ol>
<li>A subclass of a non-POD type can insert its fields into the padding of
the base class.</li>
</ol>
<p>So a subclass of <code>T</code> may have its first field inside the padding adjacent to
<code>b</code>:</p>
<pre><code><span class="keyword">class</span> S : T <span class="punct">{</span> i32 c<span class="punct">;</span> <span class="punct">}</span><span class="punct">;</span>
</code></pre>
<p>In this example, <code>size_of&lt;S&gt;() == size_of&lt;T&gt;()</code> because <code>c</code> sits inside the
trailing padding of <code>T</code>.</p>
<ol start="2">
<li>A class with a <code>[[no_unique_address]]</code> field may insert other fields
below it into the padding of the <code>[[no_unique_address]]</code> field.</li>
</ol>
<p>So a class that contains <code>T</code> as a field can insert another field into <code>T</code>:</p>
<pre><code><span class="keyword">class</span> S <span class="punct">{</span> <span class="punct">[</span><span class="punct">[</span>no_unique_address<span class="punct">]</span><span class="punct">]</span> T t<span class="punct">;</span> i32 c<span class="punct">;</span> <span class="punct">}</span><span class="punct">;</span>
</code></pre>
<p>In this example, <code>size_of&lt;S&gt;() == sizeof&lt;T&gt;()</code> because <code>c</code> sits inside the
trailing padding of <code>T</code>.</p>
<p>So the `data_size_of<T>() algorithm (to determine how much to memcpy
safely) is something like:</p>
<ul>
<li>A: find out how many bytes fit into the padding via inheritance
(<code>struct S : T { bytes }</code> for all <code>bytes</code> until
<code>size_of&lt;T&gt;() != size_of&lt;S&gt;()</code>).</li>
<li>B: find out how many bytes fit into the padding via no_unique_address
(<code>struct S { [[no_unique_address]] T x; bytes }</code> for all <code>bytes</code> until
<code>size_of&lt;T&gt;() != size_of&lt;S&gt;()</code>).</li>
</ul>
<pre><code><span class="keyword">return</span> size_of<span class="punct">&lt;</span>T<span class="punct">&gt;</span><span class="punct">(</span><span class="punct">)</span> <span class="punct">-</span> max<span class="punct">(</span>A<span class="punct">,</span> B<span class="punct">)</span>
</code></pre>
<p>From @danakj:</p>
<p>You might think that A == B however it is not required, as implementations
may have different behaviour for inheritance vs <code>[[no_unique_address]]</code>.</p>
<p>On MSVC 19, an empty class has size 1, but with the above formula:</p>
<ul>
<li>A = 1, as the 1 byte gets reused by a subclass.</li>
<li>B = 0, as [[no_unique_address]] does not reuse the one byte of the empty
class.</li>
</ul>
<p>The result is that the <code>data_size_of&lt;T&gt;()</code> should be 0, since the 1 byte
<em>can</em> be reused.</p>
<p>In general, [[no_unique_address]] and [[msvc::no_unique_address]] doesn't
appear do anything on MSVC 19, and subclasses also do not use padding
bytes of the base class, with the exception of the base class being empty
This may change in future versions of the compiler.</p>

            </div>
          </div>
        </div>
      </section>
    </main>
  </body>
</html>
