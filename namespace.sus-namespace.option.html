<!DOCTYPE html>

<head>
  <meta name="generator" content="subdoc"></meta>
  <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
  <title>sus::option - Subspace</title>
  <meta name="description" content="The Option type, and the
some and none
type-deduction constructor functions."></meta>
  <link rel="stylesheet" href="subdoc-test-style.css">
</head>

<body>
  <div class="namespace">
    <div class="section overview">
      <div class="section-header">
        <span>
          Namespace
        </span>
        <a class="project-name" href="index.html">Subspace</a>
        <span class="namespace-dots">::</span>
        <a class="namespace-name" href="namespace.sus.html">sus</a>
        <span class="namespace-dots">::</span>
        <a class="namespace-name" href="#">option</a>
      </div>
      <div class="description long">
        <p>The <a href="sus-option-Option.html"><code>Option</code></a> type, and the
<a href="sus-option-fn.some.html"><code>some</code></a> and <a href="sus-option-fn.none.html"><code>none</code></a>
type-deduction constructor functions.</p>
<p>The <a href="sus-option-Option.html"><code>Option</code></a> type represents an optional value:
every <a href="sus-option-Option.html"><code>Option</code></a> is either Some and contains a
value, or None, and does not. It is similar to
<a href="https://en.cppreference.com/w/cpp/utility/optional"><code>std::optional</code></a> but
with some differences:</p>
<ul>
<li>Extensive vocabulary for combining <a href="sus-option-Option.html"><code>Option</code></a>s
together.</li>
<li>Safe defined behaviour (a panic) when unwrapping an empty
<a href="sus-option-Option.html"><code>Option</code></a>, with an
explicit unsafe backdoor
(<a href="sus-option-Option.html#method.unwrap_unchecked"><code>unwrap_unchecked</code></a>)
for when it is needed.</li>
<li>Avoid accidental expensive copies. Supports <a href="sus-mem-Copy.html"><code>Copy</code></a> if
the inner type is
<a href="sus-mem-Copy.html"><code>Copy</code></a> and <a href="sus-mem-Clone.html"><code>Clone</code></a> if the inner
type is <a href="sus-mem-Clone.html"><code>Clone</code></a>.</li>
<li>Provides <a href="sus-option-Option.html#method.take"><code>take()</code></a> to move a value
out of an lvalue <a href="sus-option-Option.html"><code>Option</code></a>, which mark the
lvalue as empty instead of leaving a moved-from value behind as with
<code>std::move(optional).value()</code>.</li>
<li>A custom message can be printed when trying to unwrap an empty
<a href="sus-option-Option.html"><code>Option</code></a>.</li>
<li>Subspace <a href="sus-iter.html">Iterator</a> integration.
<a href="sus-option-Option.html"><code>Option</code></a> can be iterated
over, acting like a single-element <a href="sus-collections.html">collection</a>,
which allows it to be chained together with other iterators, filtered,
etc.</li>
</ul>
<p><a href="sus-option-Option.html"><code>Option</code></a> types are very common, as they have a
number of uses:</p>
<ul>
<li>Initial values</li>
<li>Return values for functions that are not defined over their entire input
range (partial functions)</li>
<li>Return value for otherwise reporting simple errors, where <code>None</code> is
returned   on error.</li>
<li>Optional struct fields Struct fields that can be loaned or &quot;taken&quot;</li>
<li>Optional function arguments</li>
<li>Returning an optional reference to a member</li>
</ul>
<h1><a name="quick-start" href="#quick-start">Quick start</a></h1>
<p>When the type is known to the compiler, you can construct an
<a href="sus-option-Option.html"><code>Option</code></a> from a value without writing the full
type again, by using
<a href="sus-option-fn.some.html"><code>sus::some(x)</code></a> to make an
<a href="sus-option-Option.html"><code>Option</code></a> holding <code>x</code> or
<a href="sus-option-fn.none.html"><code>sus::none()</code></a> to make an empty
<a href="sus-option-Option.html"><code>Option</code></a>. If returning an
<a href="sus-option-Option.html"><code>Option</code></a> from a lambda, be sure to specify the
return type on the lambda to allow successful type deduction.</p>
<pre><code>// Returns Some(&quot;power!&quot;) if the input is over 9000, or None otherwise.
auto is_power = [](i32 i) -&gt; sus::Option&lt;std::string&gt; {
  if (i &gt; 9000) return sus::some(&quot;power!&quot;);
  return sus::none();
};
</code></pre>
<p>Use <a href="sus-option-Option.html#method.is_some"><code>is_some</code></a> and
<a href="sus-option-Option.html#method.is_none"><code>is_none</code></a> to see if the
<a href="sus-option-Option.html"><code>Option</code></a> is holding a value.</p>
<p>To immediately pull the inner value out of an
<a href="sus-option-Option.html"><code>Option</code></a> an an rvalue, use
<a href="sus-option-Option.html#method.unwrap"><code>unwrap</code></a>. If the
<a href="sus-option-Option.html"><code>Option</code></a> is an lvalue, use
<a href="sus-option-Option.html#method.as_value"><code>as_value</code></a> and
<a href="sus-option-Option.html#method.as_value_mut"><code>as_value_mut</code></a> to access the
inner value. Like
<a href="https://en.cppreference.com/w/cpp/utility/optional"><code>std::optional</code></a>,
<a href="sus-option-Option.html#method.operator*"><code>operator*</code></a> and
<a href="sus-option-Option.html#method.operator-%3E"><code>operator-&gt;</code></a> are also
available if preferred. However if doing this many times, consider doing
<a href="sus-option-Option.html#method.unwrap"><code>unwrap</code></a> a single time up front.</p>
<pre><code>sus::check(is_power(9001).unwrap() == &quot;power!&quot;);

if (Option&lt;std::string&gt; lvalue = is_power(9001); lvalue.is_some())
  sus::check(lvalue.as_value() == &quot;power!&quot;);

sus::check(is_power(9000).unwrap_or(&quot;unlucky&quot;) == &quot;unlucky&quot;);
</code></pre>
<p><a href="sus-option-Option.html"><code>Option&lt;const T&gt;</code></a> for non-reference-type <code>T</code>
is disallowed, as the <a href="sus-option-Option.html"><code>Option</code></a>
owns the <code>T</code> in that case and it ensures the
<a href="sus-option-Option.html"><code>Option</code></a> and the <code>T</code> are both
accessed with the same constness.</p>
<h1><a name="representation" href="#representation">Representation</a></h1>
<p>If a type <code>T</code> is a reference or satisties
<a href="sus-mem-NeverValueField.html"><code>NeverValueField</code></a>, then
<a href="sus-option-Option.html"><code>Option&lt;T&gt;</code></a> will have the same size as T and
will be internally represented as just a <code>T</code> (or <code>T*</code> in the case of
a reference <code>T&amp;</code>).</p>
<p>The following types <code>T</code>, when stored in an
<a href="sus-option-Option.html"><code>Option&lt;T&gt;</code></a>, will have the same
size as the original type <code>T</code>:</p>
<ul>
<li><code>const T&amp;</code> or <code>T&amp;</code> (have the same size as <code>const T*</code> or <code>T*</code>)</li>
<li><a href="sus-ptr-NonNull.html"><code>ptr::NonNull&lt;U&gt;</code></a></li>
</ul>
<p>This is called the &quot;NeverValueField optimization&quot;, but is also called the
<a href="https://doc.rust-lang.org/stable/std/option/index.html#representation">&quot;null pointer optimization&quot; or NPO in Rust</a>.</p>
<h1><a name="querying-the-variant" href="#querying-the-variant">Querying the variant</a></h1>
<p>The <a href="sus-option-Option.html#method.is_some"><code>is_some</code></a> and
<a href="sus-option-Option.html#method.is_none"><code>is_none</code></a> methods return
<code>true</code> if the <a href="sus-option-Option.html"><code>Option</code></a> is
holding a value or not, respectively.</p>
<h1><a name="adapters-for-working-with-lvalues" href="#adapters-for-working-with-lvalues">Adapters for working with lvalues</a></h1>
<p>The following methods allow you to create an
<a href="sus-option-Option.html"><code>Option</code></a> that refers to the value
held in an lvalue, without copying or moving from the lvalue:</p>
<ul>
<li><a href="sus-option-Option.html#method.as_ref"><code>as_ref</code></a> converts from a const
lvalue <a href="sus-option-Option.html"><code>Option&lt;T&gt;</code></a> to an rvalue
<a href="sus-option-Option.html"><code>Option&lt;const T&amp;&gt;</code></a>`.</li>
<li><a href="sus-option-Option.html#method.as_mut"><code>as_mut</code></a> converts from a mutable
lvalue <a href="sus-option-Option.html"><code>Option&lt;T&gt;</code></a> to an rvalue
<a href="sus-option-Option.html"><code>Option&lt;T&amp;&gt;</code></a>.</li>
<li><a href="sus-option-Option.html#method.take"><code>take</code></a> moves the element out of
the lvalue <a href="sus-option-Option.html"><code>Option&lt;T&gt;</code></a> into an rvalue
<a href="sus-option-Option.html"><code>Option&lt;T&gt;</code></a>, leaving the lvalue empty.</li>
</ul>
<h1><a name="extracting-the-contained-value" href="#extracting-the-contained-value">Extracting the contained value</a></h1>
<p>These methods extract the contained value in an <a href="sus-option-Option.html"><code>Option&lt;T&gt;</code></a> when it is
holding a value.</p>
<p>For working with the option as an lvalue:</p>
<ul>
<li><a href="sus-option-Option.html#method.as_value"><code>as_value</code></a> returns const
reference access to the inner value. It will panic with a generic
message when empty.</li>
<li><a href="sus-option-Option.html#method.as_value_mut"><code>as_value_mut</code></a> returns
mutable reference access to the inner value. It will panic with a
generic message when empty.</li>
<li><a href="sus-option-Option.html#method.operator*"><code>operator*</code></a> returns mutable
reference access to the inner value. It will panic with a generic message
when empty.</li>
<li><a href="sus-option-Option.html#method.operator-%3E"><code>operator-&gt;</code></a> returns mutable
pointer access to the inner value. It will panic with a generic message
when empty.</li>
</ul>
<p>For working with the option as an rvalue (when it returned from a function
call):</p>
<ul>
<li><a href="sus-option-Option.html#method.expect"><code>expect</code></a> moves and returns the
inner value. It will panic with a provided custom message when empty.</li>
<li><a href="sus-option-Option.html#method.unwrap"><code>unwrap</code></a> moves and returns the
inner value. It will panic with a generic message with empty.</li>
<li><a href="sus-option-Option.html#method.unwrap_or"><code>unwrap_or</code></a> moves and returns
the inner value. It will returns the provided default value instead when
empty.</li>
<li><a href="sus-option-Option.html#method.unwrap_or_default"><code>unwrap_or_default</code></a>
moves and returns the inner value. It will return the default value of
the type <code>T</code> (which must satisfy <a href="sus-construct-Default.html"><code>Default</code></a>)
when empty.</li>
<li><a href="sus-option-Option.html#method.unwrap_or_else"><code>unwrap_or_else</code></a> moves
and returns the inner value. It will return the result of evaluating
the provided function when empty.</li>
</ul>
<h1><a name="copying" href="#copying">Copying</a></h1>
<p>Most methods of Option act on an rvalue and consume the Option to transform
it into a new Option with a new value. This ensures that the value inside an
Option is moved while transforming it.</p>
<p>However, if <a href="sus-option-Option.html"><code>Option</code></a> is
<a href="sus-mem-Copy.html"><code>Copy</code></a>, then the majority of methods offer an
overload to be called as an lvalue, in which case the
<a href="sus-option-Option.html"><code>Option</code></a> will copy
itself, and its contained value, and perform the intended method on the copy
instead. This can have performance implications!</p>
<p>The unwrapping methods are excluded from this, and are only available on an
rvalue <a href="sus-option-Option.html"><code>Option</code></a> to avoid copying just to access
the inner value. To do that, access the inner value as a reference through
<a href="sus-option-Option.html#method.as_value"><code>as_value</code></a> and
<a href="sus-option-Option.html#method.as_value_mut"><code>as_value_mut</code></a> or through
<a href="sus-option-Option.html#method.operator*"><code>operator*</code></a> and
<a href="sus-option-Option.html#method.operator-%3E"><code>operator-&gt;</code></a>.</p>
<h1><a name="transforming-contained-values" href="#transforming-contained-values">Transforming contained values</a></h1>
<p>These methods transform <a href="sus-option-Option.html"><code>Option</code></a> to
<a href="sus-result-Result.html"><code>Result</code></a>:</p>
<ul>
<li><a href="sus-option-Option.html#method.ok_or"><code>ok_or</code></a> transforms <code>Some(v)</code>
to <code>Ok(v)</code>, and <code>None</code> to <code>Err(err)</code> using the provided default err value.</li>
<li><a href="sus-option-Option.html#method.ok_or_else"><code>ok_or_else</code></a> transforms
<code>Some(v)</code> to <code>Ok(v)</code>, and <code>None</code> to a value of <code>Err</code> using the
provided function.</li>
<li><a href="sus-option-Option.html#method.transpose"><code>transpose</code></a> transposes an
<a href="sus-option-Option.html"><code>Option</code></a> of a <a href="sus-result-Result.html"><code>Result</code></a>
into a <a href="sus-result-Result.html"><code>Result</code></a> of an
<a href="sus-option-Option.html"><code>Option</code></a>.</li>
</ul>
<p>These methods transform an option holding a value:</p>
<ul>
<li><a href="sus-option-Option.html#method.filter"><code>filter</code></a> calls the provided
predicate function on the contained value <code>t</code> if the
<a href="sus-option-Option.html"><code>Option</code></a> is <code>Some(t)</code>, and returns <code>Some(t)</code>
if the function returns <code>true</code>; otherwise, returns <code>None</code>.</li>
<li><a href="sus-option-Option.html#method.flatten"><code>flatten</code></a> removes one level
of nesting from an <code>Option&lt;Option&lt;T&gt;&gt;</code>.</li>
<li><a href="sus-option-Option.html#method.map"><code>map</code></a> transforms
<a href="sus-option-Option.html"><code>Option&lt;T&gt;</code></a> to
<a href="sus-option-Option.html"><code>Option&lt;U&gt;</code></a> by applying the provided
function to the contained value of <code>Some</code> and leaving <code>None</code> values
unchanged.</li>
</ul>
<p>These methods transform <a href="sus-option-Option.html"><code>Option&lt;T&gt;</code></a> to a value
of a possibly different type <code>U</code>:</p>
<ul>
<li><a href="sus-option-Option.html#method.map_or"><code>map_or</code></a> applies the provided
function to the contained value of <code>Some</code>, or returns the provided
default value if the
<a href="sus-option-Option.html"><code>Option</code></a> is <code>None</code>.</li>
<li><a href="sus-option-Option.html#method.map_or_else"><code>map_or_else</code></a> applies the
provided function to the contained value of <code>Some</code>, or returns the result
of evaluating the provided fallback function if the
<a href="sus-option-Option.html"><code>Option</code></a> is <code>None</code>.</li>
</ul>
<p>These methods combine the Some variants of two Option values:</p>
<ul>
<li><a href="sus-option-Option.html#method.zip"><code>zip</code></a> returns <code>Some(Tuple&lt;S, O&gt;(s, o)))</code> if the
<a href="sus-option-Option.html"><code>Option</code></a> is <code>Some(s)</code>
and the method is called with an <a href="sus-option-Option.html"><code>Option</code></a> value of <code>Some(o)</code>; otherwise,
returns <code>None</code></li>
<li>TODO: <a href="sus-option-Option.html#method.zip_with"><code>zip_with</code></a> calls the provided function <code>f</code> and returns
<code>Some(f(s, o))</code> if the <a href="sus-option-Option.html"><code>Option</code></a> is Some(s)
and the method is called with an <a href="sus-option-Option.html"><code>Option</code></a>
value of <code>Some(o)</code>; otherwise, returns <code>None</code>.</li>
</ul>
<h1><a name="boolean-operators" href="#boolean-operators">Boolean operators</a></h1>
<p>These methods treat the <a href="sus-option-Option.html"><code>Option</code></a> as a boolean value,
where <code>Some</code> acts like <code>true</code> and <code>None</code> acts like <code>false</code>. There are two
categories of these methods: ones that take an
<a href="sus-option-Option.html"><code>Option</code></a> as input, and ones
that take a function as input (to be lazily evaluated).</p>
<p>The <a href="sus-option-Option.html#method.and_that"><code>and_that</code></a>,
<a href="sus-option-Option.html#method.or_that"><code>or_that</code></a>,
and <a href="sus-option-Option.html#method.xor_that"><code>xor_that</code></a> methods take
another <a href="sus-option-Option.html"><code>Option</code></a> as input, and produce an
<a href="sus-option-Option.html"><code>Option</code></a> as output.
Only the <a href="sus-option-Option.html#method.and_that"><code>and_that</code></a>
method can produce an <a href="sus-option-Option.html"><code>Option&lt;U&gt;</code></a> value having a different inner type <code>U</code>
than <a href="sus-option-Option.html"><code>Option&lt;T&gt;</code></a>.</p>
<table>
<thead>
<tr>
<th>method</th>
<th>self</th>
<th>input</th>
<th>output</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="sus-option-Option.html#method.and_that"><code>and_that</code></a></td>
<td>None</td>
<td>(ignored)</td>
<td>None</td>
</tr>
<tr>
<td><a href="sus-option-Option.html#method.and_that"><code>and_that</code></a></td>
<td>Some(x)</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td><a href="sus-option-Option.html#method.and_that"><code>and_that</code></a></td>
<td>Some(x)</td>
<td>Some(y)</td>
<td>Some(y)</td>
</tr>
<tr>
<td><a href="sus-option-Option.html#method.or_that"><code>or_that</code></a></td>
<td>None</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td><a href="sus-option-Option.html#method.or_that"><code>or_that</code></a></td>
<td>None</td>
<td>Some(y)</td>
<td>Some(y)</td>
</tr>
<tr>
<td><a href="sus-option-Option.html#method.or_that"><code>or_that</code></a></td>
<td>Some(x)</td>
<td>(ignored)</td>
<td>Some(x)</td>
</tr>
<tr>
<td><a href="sus-option-Option.html#method.xor_that"><code>xor_that</code></a></td>
<td>None</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td><a href="sus-option-Option.html#method.xor_that"><code>xor_that</code></a></td>
<td>None</td>
<td>Some(y)</td>
<td>Some(y)</td>
</tr>
<tr>
<td><a href="sus-option-Option.html#method.xor_that"><code>xor_that</code></a></td>
<td>Some(x)</td>
<td>None</td>
<td>Some(x)</td>
</tr>
<tr>
<td><a href="sus-option-Option.html#method.xor_that"><code>xor_that</code></a></td>
<td>Some(x)</td>
<td>Some(y)</td>
<td>None</td>
</tr>
</tbody>
</table>
<p>The <a href="sus-option-Option.html#method.and_then"><code>and_then</code></a> and
<a href="sus-option-Option.html#method.or_else"><code>or_else</code></a> methods take a function
as input, and only evaluate the function when they need to produce a new
value. Only the <a href="sus-option-Option.html#method.and_then"><code>and_then</code></a> method
can produce an <a href="sus-option-Option.html"><code>Option&lt;U&gt;</code></a> value having a
different inner type <code>U</code> than <a href="sus-option-Option.html"><code>Option&lt;T&gt;</code></a>.</p>
<table>
<thead>
<tr>
<th>method</th>
<th>self</th>
<th>function input</th>
<th>function result</th>
<th>output</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="sus-option-Option.html#method.and_then"><code>and_then</code></a></td>
<td>None</td>
<td>(not provided)</td>
<td>(not evaluated)</td>
<td>None</td>
</tr>
<tr>
<td><a href="sus-option-Option.html#method.and_then"><code>and_then</code></a></td>
<td>Some(x)</td>
<td>x</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td><a href="sus-option-Option.html#method.and_then"><code>and_then</code></a></td>
<td>Some(x)</td>
<td>x</td>
<td>Some(y)</td>
<td>Some(y)</td>
</tr>
<tr>
<td><a href="sus-option-Option.html#method.or_else"><code>or_else</code></a></td>
<td>None</td>
<td>(not provided)</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td><a href="sus-option-Option.html#method.or_else"><code>or_else</code></a></td>
<td>None</td>
<td>(not provided)</td>
<td>Some(y)</td>
<td>Some(y)</td>
</tr>
<tr>
<td><a href="sus-option-Option.html#method.or_else"><code>or_else</code></a></td>
<td>Some(x)</td>
<td>(not provided)</td>
<td>(not evaluated)</td>
<td>Some(x)</td>
</tr>
</tbody>
</table>
<p>This is an example of using methods like
<a href="sus-option-Option.html#method.and_then"><code>and_then</code></a> and
<a href="sus-option-Option.html#method.or_that"><code>or_that</code></a> in a pipeline of
method calls. Early stages of the pipeline pass failure values (<code>None</code>)
through unchanged, and continue processing on success values (<code>Some</code>).
Toward the end, or substitutes an error message if it receives <code>None</code>.</p>
<pre><code>auto to_string = [](u8 u) -&gt; sus::Option&lt;std::string&gt; {
  switch (uint8_t{u}) {  // switch requires a primitive.
    case 20u: return sus::some(&quot;foo&quot;);
    case 42u: return sus::some(&quot;bar&quot;);
    default: return sus::none();
  }
};
auto res =
    sus::Vec&lt;u8&gt;(0_u8, 1_u8, 11_u8, 200_u8, 22_u8)
        .into_iter()
        .map([&amp;](auto x) {
          // `checked_sub()` returns `None` on error.
          return x.checked_sub(1_u8)
              // same with `checked_mul()`.
              .and_then([](u8 x) { return x.checked_mul(2_u8); })
              // `to_string` returns `None` on error.
              .and_then([&amp;](u8 x) { return to_string(x); })
              // Substitute an error message if we have `None` so far.
              .or_that(sus::some(std::string(&quot;error!&quot;)))
              // Won't panic because we unconditionally used `Some` above.
              .unwrap();
        })
        .collect&lt;Vec&lt;std::string&gt;&gt;();
sus::check(res == sus::vec(&quot;error!&quot;, &quot;error!&quot;, &quot;foo&quot;, &quot;error!&quot;, &quot;bar&quot;));
</code></pre>
<h1><a name="restrictions-on-returning-references" href="#restrictions-on-returning-references">Restrictions on returning references</a></h1>
<p>Methods that return references are only callable on an rvalue
<a href="sus-option-Option.html"><code>Option</code></a> if the
<a href="sus-option-Option.html"><code>Option</code></a> is holding a reference. If the
<a href="sus-option-Option.html"><code>Option</code></a> is holding a non-reference
type, returning a reference from an rvalue
<a href="sus-option-Option.html"><code>Option</code></a> would be giving a reference to a
short-lived object which is a bugprone pattern in C++ leading to
memory-safety bugs.</p>

      </div>
    </div>
    <div class="section records classes">
      <div class="section-header">
        Classes
      </div>
      <ul class="section-items item-table">
        <li class="section-item">
          <div class="item-name">
            <div class="type-signature">
              <a class="type-name" href="namespace.sus-namespace.option-Option.html">Option</a>
            </div>
          </div>
          <div class="description short">
            <p>The <a href="sus-option-Option.html"><code>Option</code></a> type.</p>
          </div>
        </li>
      </ul>
    </div>
    <div class="section functions">
      <div class="section-header">
        Functions
      </div>
      <ul class="section-items item-table">
        <li class="section-item">
          <div class="overload-set item-name">
            <div class="overload">
              <div class="function-signature"><a class="function-name" href="namespace.sus-namespace.option-fn.none.html">none</a></div>
            </div>
          </div>
          <div class="description short">
            <p>Used to construct an option with a None value.</p>
          </div>
        </li>
        <li class="section-item">
          <div class="overload-set item-name">
            <div class="overload">
              <div class="function-signature"><a class="function-name" href="namespace.sus-namespace.option-fn.some.html">some</a></div>
            </div>
          </div>
          <div class="description short">
            <p>Used to construct an option with a Some(t) value.</p>
          </div>
        </li>
      </ul>
    </div>
    <div class="section functions">
      <div class="section-header">
        Operators
      </div>
      <ul class="section-items item-table">
        <li class="section-item">
          <div class="overload-set item-name">
            <div class="overload">
              <div class="function-signature"><a class="function-name" href="namespace.sus-namespace.option-fn.operator_spaceship.html">operator&lt;=&gt;</a></div>
            </div>
          </div>
          <div class="description short">
            <p>Compares two options.</p>
          </div>
        </li>
        <li class="section-item">
          <div class="overload-set item-name">
            <div class="overload">
              <div class="function-signature"><a class="function-name" href="namespace.sus-namespace.option-fn.operator_eq.html">operator==</a></div>
            </div>
          </div>
          <div class="description short">
            <p>Satisfies the <a href="sus-ops-Eq.html"><code>Eq&lt;Option&lt;U&gt;&gt;</code></a> concept.</p>
          </div>
        </li>
      </ul>
    </div>
  </div>
</body>
