<!DOCTYPE html>

<head>
  <meta name="generator" content="subdoc"></meta>
  <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
  <title>sus::result::Result - Subspace</title>
  <meta name="description" content=""></meta>
  <link rel="stylesheet" href="subdoc-test-style.css">
</head>

<body>
  <div class="type record class">
    <div class="section overview">
      <div class="section-header">
        <span>
          Class
        </span>
        <a class="project-name" href="index.html">Subspace</a>
        <span class="namespace-dots">::</span>
        <a class="namespace-name" href="namespace.sus.html">sus</a>
        <span class="namespace-dots">::</span>
        <a class="namespace-name" href="namespace.sus-namespace.result.html">result</a>
        <span class="namespace-dots">::</span>
        <a class="type-name" href="#">Result</a>
      </div>
      <div class="type-signature">
        <div class="template">template &lt;class T, class E&gt;</div>
        <span class="class">
          class
        </span>
        <span class="type-name">
          Result
        </span>
        <span class="final">
          final
        </span>
        <div class="record-body">
          { ... };
        </div>
      </div>
      <div class="description long">
      </div>
    </div>
    <div class="section methods static">
      <div class="section-header">
        Static Methods
      </div>
      <div class="section-items">
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><a class="function-name" name="method.Result.ctor.ok" href="namespace.sus-namespace.result-Result.html#method.Result.ctor.ok">Result</a>(<a class="type-name" title="struct OkVoid" href="namespace.sus-namespace.result-OkVoid.html">OkVoid</a>)</div>
          </div>
          <div class="overload">
            <div class="function-signature"><a class="function-name" name="method.Result.ctor.ok" href="namespace.sus-namespace.result-Result.html#method.Result.ctor.ok">Result</a>(const TUnlessVoid & t)</div>
          </div>
          <div class="overload">
            <div class="function-signature"><a class="function-name" name="method.Result.ctor.ok" href="namespace.sus-namespace.result-Result.html#method.Result.ctor.ok">Result</a>(TUnlessVoid && t)</div>
          </div>
          <div class="overload">
            <div class="function-signature"><div class="template">template &lt;class U&gt;</div><a class="function-name" name="method.Result.ctor.ok" href="namespace.sus-namespace.result-Result.html#method.Result.ctor.ok">Result</a>(U && t)</div>
          </div>
        </div>
        <div class="description long">
          <p>Construct an Result that is holding the given success value.</p>
<h1><a name="const-references" href="#const-references">Const References</a></h1>
<p>For <code>Result&lt;const T&amp;, E&gt;</code> it is possible to bind to a temporary which
would create a memory safety bug. The <code>[[clang::lifetimebound]]</code> attribute
is used to prevent this via Clang. But additionally, the incoming type is
required to match with <code>sus::construct::SafelyConstructibleFromReference</code>
to prevent conversions that would construct a temporary.</p>
<p>To force accepting a const reference anyway in cases where a type can
convert to a reference without constructing a temporary, use an unsafe
<code>static_cast&lt;const T&amp;&gt;()</code> at the callsite (and document it =)).</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><a class="function-name" name="method.Result.copy" href="namespace.sus-namespace.result-Result.html#method.Result.copy">Result</a>(<a class="type-name" title="const Result&lt;T, E&gt; &" href="namespace.sus-namespace.result-Result.html">const Result&lt;T, E&gt; &</a>)</div>
          </div>
        </div>
        <div class="description long">
          <p>Copy constructor for <code>Result&lt;T, E&gt;</code> which satisfies
<a href="sus-mem-Copy.html"><code>sus::mem::Copy&lt;Result&lt;T, E&gt;&gt;</code></a> if
<a href="sus-mem-Copy.html"><code>Copy&lt;T&gt;</code></a> and
<a href="sus-mem-Copy.html"><code>Copy&lt;E&gt;</code></a> are satisfied.</p>
<p>If <code>T</code> and <code>E</code> can be trivially copy-constructed, then <code>Result&lt;T, E&gt;</code> can
also be trivially copy-constructed.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><a class="function-name" name="method.Result.move" href="namespace.sus-namespace.result-Result.html#method.Result.move">Result</a>(<a class="type-name" title="Result&lt;T, E&gt; &&" href="namespace.sus-namespace.result-Result.html">Result&lt;T, E&gt; &&</a>)</div>
          </div>
        </div>
        <div class="description long">
          <p>Move constructor for <code>Result&lt;T, E&gt;</code> which satisfies
<a href="sus-mem-Move.html"><code>sus::mem::Move&lt;Result&lt;T, E&gt;&gt;</code></a> if
<a href="sus-mem-Move.html"><code>Move&lt;T&gt;</code></a> and
<a href="sus-mem-Move.html"><code>Move&lt;E&gt;</code></a> are satisfied.</p>
<p>If <code>T</code> and <code>E</code> can be trivially move-constructed, then <code>Result&lt;T, E&gt;</code> can
also be trivially move-constructed. When trivially-moved, the <code>Result</code> is
copied on move, and the moved-from Result is unchanged but should still
not be used thereafter without reinitializing it.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><div class="template">template &lt;class Iter&gt;</div><span class="static">static</span><span class="function-auto">auto</span><a class="function-name" name="method.from_product" href="namespace.sus-namespace.result-Result.html#method.from_product">from_product</a>(Iter && it) -&gt; <a class="type-name" title="Result&lt;T, E&gt;" href="namespace.sus-namespace.result-Result.html">Result&lt;T, E&gt;</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Computes the product of an iterator over <code>Result&lt;T, E&gt;</code> as long as there
is no <code>Err</code> found. If an <code>Err</code> is found, the function returns the first
<code>Err</code>.</p>
<p>Prefer to call <code>product()</code> on the iterator rather than calling
<code>from_product()</code> directly.</p>
<p>Implements sus::iter::Product&lt;Result&lt;T, E&gt;, Result&lt;T, E&gt;&gt;.</p>
<p>The product is computed using the implementation of the inner type <code>T</code>
which also satisfies <code>sus::iter::Product&lt;T, T&gt;</code>.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><div class="template">template &lt;class Iter&gt;</div><span class="static">static</span><span class="function-auto">auto</span><a class="function-name" name="method.from_sum" href="namespace.sus-namespace.result-Result.html#method.from_sum">from_sum</a>(Iter && it) -&gt; <a class="type-name" title="Result&lt;T, E&gt;" href="namespace.sus-namespace.result-Result.html">Result&lt;T, E&gt;</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Computes the sum of an iterator over <code>Result&lt;T, E&gt;</code> as long as there
is no <code>Err</code> found. If an <code>Err</code> is found, the function returns the first
<code>Err</code>.</p>
<p>Prefer to call <code>sum()</code> on the iterator rather than calling <code>from_sum()</code>
directly.</p>
<p>Implements sus::iter::Sum&lt;Result&lt;T, E&gt;, Result&lt;T, E&gt;&gt;.</p>
<p>The sum is computed using the implementation of the inner type <code>T</code>
which also satisfies <code>sus::iter::Sum&lt;T, T&gt;</code>.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="static">static</span><span class="function-auto">auto</span><a class="function-name" name="method.with_err" href="namespace.sus-namespace.result-Result.html#method.with_err">with_err</a>(const E & e) -&gt; <a class="type-name" title="Result&lt;T, E&gt;" href="namespace.sus-namespace.result-Result.html">Result&lt;T, E&gt;</a></div>
          </div>
          <div class="overload">
            <div class="function-signature"><span class="static">static</span><span class="function-auto">auto</span><a class="function-name" name="method.with_err" href="namespace.sus-namespace.result-Result.html#method.with_err">with_err</a>(E && e) -&gt; <a class="type-name" title="Result&lt;T, E&gt;" href="namespace.sus-namespace.result-Result.html">Result&lt;T, E&gt;</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Construct an Result that is holding the given error value.</p>

        </div>
      </div>
    </div>
    <div class="section methods nonstatic">
      <div class="section-header">
        Methods
      </div>
      <div class="section-items">
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><div class="template">template &lt;class AndFn, int &... , class R = std::invoke_result_t&lt;AndFn, TUnlessVoid &&&gt;, class OkType = typename __private::IsResultType&lt;R&gt;::ok_type, class ErrType = typename __private::IsResultType&lt;R&gt;::err_type&gt;</div><span class="function-auto">auto</span><a class="function-name" name="method.and_then" href="namespace.sus-namespace.result-Result.html#method.and_then">and_then</a>(AndFn && op) && -&gt; Result&lt;OkType, ErrType&gt;</div>
          </div>
        </div>
        <div class="description long">
          <p>Calls <code>op</code> if the result is <code>Ok</code>, otherwise returns the <code>Err</code> value of
self.</p>
<p>This function can be used for control flow based on <code>Result</code> values.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.as_err" href="namespace.sus-namespace.result-Result.html#method.as_err">as_err</a>() const& -&gt; remove_reference_t&lt;E&gt; &</div>
          </div>
        </div>
        <div class="description long">
          <p>Returns a const reference to the contained <code>Err</code> value.</p>
<h1><a name="panics" href="#panics">Panics</a></h1>
<p>Panics if the value is an <code>Ok</code> or the Result is moved from.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.as_value" href="namespace.sus-namespace.result-Result.html#method.as_value">as_value</a>() const& -&gt; remove_reference_t&lt;TUnlessVoid&gt; &</div>
          </div>
        </div>
        <div class="description long">
          <p>Returns a const reference to the contained <code>Ok</code> value.</p>
<h1><a name="panics-1" href="#panics-1">Panics</a></h1>
<p>Panics if the value is an <code>Err</code>.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.as_value_mut" href="namespace.sus-namespace.result-Result.html#method.as_value_mut">as_value_mut</a>() & -&gt; remove_reference_t&lt;TUnlessVoid&gt; &</div>
          </div>
        </div>
        <div class="description long">
          <p>Returns a mutable reference to the contained <code>Ok</code> value.</p>
<h1><a name="panics-2" href="#panics-2">Panics</a></h1>
<p>Panics if the value is an <code>Err</code>.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.clone" href="namespace.sus-namespace.result-Result.html#method.clone">clone</a>() const& -&gt; <a class="type-name" title="Result&lt;T, E&gt;" href="namespace.sus-namespace.result-Result.html">Result&lt;T, E&gt;</a></div>
          </div>
        </div>
        <div class="description long">
        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.clone_from" href="namespace.sus-namespace.result-Result.html#method.clone_from">clone_from</a>(<a class="type-name" title="const Result&lt;T, E&gt; &" href="namespace.sus-namespace.result-Result.html">const Result&lt;T, E&gt; &</a> source) & -&gt; void</div>
          </div>
        </div>
        <div class="description long">
        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.err" href="namespace.sus-namespace.result-Result.html#method.err">err</a>() && -&gt; Option&lt;E&gt;</div>
          </div>
        </div>
        <div class="description long">
          <p>Converts from <code>Result&lt;T, E&gt;</code> to <code>Option&lt;E&gt;</code>.</p>
<p>Converts self into an <code>Option&lt;E&gt;</code>, consuming self, and discarding the
success value, if any.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.expect" href="namespace.sus-namespace.result-Result.html#method.expect">expect</a>(const char * msg) && -&gt; T</div>
          </div>
        </div>
        <div class="description long">
          <p>Returns the contained <code>Ok</code> value, consuming the self value.</p>
<p>Because this function may panic, its use is generally discouraged.
Instead, prefer to use pattern matching and handle the <code>Err</code> case
explicitly, or call <code>unwrap_or</code>, <code>unwrap_or_else</code>, or <code>unwrap_or_default</code>.</p>
<h1><a name="panics-3" href="#panics-3">Panics</a></h1>
<p>Panics if the value is an Err, with a panic message including the passed
message, and the content of the Err.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.into_iter" href="namespace.sus-namespace.result-Result.html#method.into_iter">into_iter</a>() && -&gt; Once&lt;T&gt;</div>
          </div>
        </div>
        <div class="description long">
        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.is_err" href="namespace.sus-namespace.result-Result.html#method.is_err">is_err</a>() const& -&gt; bool</div>
          </div>
        </div>
        <div class="description long">
          <p>Returns true if the result is <code>Err</code>.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.is_ok" href="namespace.sus-namespace.result-Result.html#method.is_ok">is_ok</a>() const& -&gt; bool</div>
          </div>
        </div>
        <div class="description long">
          <p>Returns true if the result is <code>Ok</code>.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.iter" href="namespace.sus-namespace.result-Result.html#method.iter">iter</a>() const& -&gt; Once&lt;const std::remove_reference_t&lt;TUnlessVoid&gt; &&gt;</div>
          </div>
        </div>
        <div class="description long">
        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.iter_mut" href="namespace.sus-namespace.result-Result.html#method.iter_mut">iter_mut</a>() & -&gt; Once&lt;TUnlessVoid &&gt;</div>
          </div>
        </div>
        <div class="description long">
        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.ok" href="namespace.sus-namespace.result-Result.html#method.ok">ok</a>() && -&gt; Option&lt;T&gt;</div>
          </div>
        </div>
        <div class="description long">
          <p>Converts from <code>Result&lt;T, E&gt;</code> to <code>Option&lt;T&gt;</code>.</p>
<p>Converts self into an <code>Option&lt;T&gt;</code>, consuming self, and discarding the
error, if any.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.unwrap" href="namespace.sus-namespace.result-Result.html#method.unwrap">unwrap</a>() && -&gt; T</div>
          </div>
        </div>
        <div class="description long">
          <p>Returns the contained <code>Ok</code> value, consuming the self value.</p>
<p>Because this function may panic, its use is generally discouraged.
Instead, prefer to use pattern matching and handle the <code>Err</code> case
explicitly, or call <code>unwrap_or()</code>, <code>unwrap_or_else()</code>, or
<code>unwrap_or_default()</code>.</p>
<h1><a name="panics-4" href="#panics-4">Panics</a></h1>
<p>Panics if the value is an <code>Err</code> or the Result is moved from.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.unwrap_err" href="namespace.sus-namespace.result-Result.html#method.unwrap_err">unwrap_err</a>() && -&gt; E</div>
          </div>
        </div>
        <div class="description long">
          <p>Returns the contained <code>Err</code> value, consuming the self value.</p>
<h1><a name="panics-5" href="#panics-5">Panics</a></h1>
<p>Panics if the value is an <code>Ok</code> or the Result is moved from.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.unwrap_err_unchecked" href="namespace.sus-namespace.result-Result.html#method.unwrap_err_unchecked">unwrap_err_unchecked</a>(<a class="type-name" title="struct ::sus::marker::UnsafeFnMarker" href="namespace.sus-namespace.marker-UnsafeFnMarker.html">UnsafeFnMarker</a>) && -&gt; E</div>
          </div>
        </div>
        <div class="description long">
          <p>Returns the contained <code>Err</code> value, consuming the self value, without
checking that the value is not an <code>Ok</code>.</p>
<h1><a name="safety" href="#safety">Safety</a></h1>
<p>Calling this method on an <code>Ok</code> or a moved-from Result is Undefined
Behavior.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.unwrap_or_default" href="namespace.sus-namespace.result-Result.html#method.unwrap_or_default">unwrap_or_default</a>() && -&gt; T</div>
          </div>
        </div>
        <div class="description long">
          <p>Returns the contained Ok value or a default.</p>
<p>Consumes the Result and, if it held an Ok value, the value is returned.
Otherwise the default value of the Ok value's type is returned.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><div class="template">template &lt;class F&gt;</div><span class="function-auto">auto</span><a class="function-name" name="method.unwrap_or_else" href="namespace.sus-namespace.result-Result.html#method.unwrap_or_else">unwrap_or_else</a>(F && op) && -&gt; T</div>
          </div>
        </div>
        <div class="description long">
          <p>Returns the contained <code>Ok</code> value or computes it from a closure.</p>
<h1><a name="examples" href="#examples">Examples</a></h1>
<p>Basic usage:</p>
<pre><code>enum ECode { ItsHappening = -1 };
auto conv = [](ECode e) { return static_cast&lt;i32&gt;(e); };
auto ok = sus::Result&lt;i32, ECode&gt;(2);
sus::check(sus::move(ok).unwrap_or_else(conv) == 2);
auto err = sus::Result&lt;i32, ECode&gt;::with_err(ItsHappening);
sus::check(sus::move(err).unwrap_or_else(conv) == -1);
</code></pre>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.unwrap_unchecked" href="namespace.sus-namespace.result-Result.html#method.unwrap_unchecked">unwrap_unchecked</a>(<a class="type-name" title="struct ::sus::marker::UnsafeFnMarker" href="namespace.sus-namespace.marker-UnsafeFnMarker.html">UnsafeFnMarker</a>) && -&gt; T</div>
          </div>
        </div>
        <div class="description long">
          <p>Returns the contained <code>Ok</code> value, consuming the self value, without
checking that the value is not an <code>Err</code>.</p>
<h1><a name="safety-1" href="#safety-1">Safety</a></h1>
<p>Calling this method on an <code>Err</code> or a moved-from Result is Undefined
Behavior.</p>

        </div>
      </div>
    </div>
    <div class="section methods conversion">
      <div class="section-header">
        Conversions
      </div>
      <div class="section-items">
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><a class="function-name" name="method.operator State" href="namespace.sus-namespace.result-Result.html#method.operator State">operator State</a>() const&</div>
          </div>
        </div>
        <div class="description long">
          <p>An operator which returns the state of the Result, either #Ok or #Err.</p>
<p>This supports the use of an Result in a <code>switch()</code>, allowing it to act as
a tagged union between &quot;success&quot; and &quot;error&quot;.</p>
<h1><a name="example" href="#example">Example</a></h1>
<p>A reimplementation of <code>Result::unwrap_or()</code>.</p>
<pre><code class="language-cpp">auto x = Result&lt;int, char&gt;(2);
switch (x) {
 case Ok:
  return sus::move(x).unwrap();
 case Err:
  return -1;
}
</code></pre>

        </div>
      </div>
    </div>
    <div class="section methods nonstatic">
      <div class="section-header">
        Operators
      </div>
      <div class="section-items">
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.operator=.copy" href="namespace.sus-namespace.result-Result.html#method.operator=.copy">operator=</a>(<a class="type-name" title="const Result&lt;T, E&gt; &" href="namespace.sus-namespace.result-Result.html">const Result&lt;T, E&gt; &</a> o) -&gt; <a class="type-name" title="Result&lt;T, E&gt; &" href="namespace.sus-namespace.result-Result.html">Result&lt;T, E&gt; &</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Copy assignment for <code>Result&lt;T, E&gt;</code> which satisfies
<a href="sus-mem-Copy.html"><code>sus::mem::Copy&lt;Result&lt;T, E&gt;&gt;</code></a> if
<a href="sus-mem-Copy.html"><code>Copy&lt;T&gt;</code></a> and
<a href="sus-mem-Copy.html"><code>Copy&lt;E&gt;</code></a> are satisfied.</p>
<p>If <code>T</code> and <code>E</code> can be trivially copy-assigned, then <code>Result&lt;T, E&gt;</code> can
also be trivially copy-assigned.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.operator=.move" href="namespace.sus-namespace.result-Result.html#method.operator=.move">operator=</a>(<a class="type-name" title="Result&lt;T, E&gt; &&" href="namespace.sus-namespace.result-Result.html">Result&lt;T, E&gt; &&</a> o) -&gt; <a class="type-name" title="Result&lt;T, E&gt; &" href="namespace.sus-namespace.result-Result.html">Result&lt;T, E&gt; &</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Move assignment for <code>Result&lt;T, E&gt;</code> which satisfies
<a href="sus-mem-Move.html"><code>sus::mem::Move&lt;Result&lt;T, E&gt;&gt;</code></a> if
<a href="sus-mem-Move.html"><code>Move&lt;T&gt;</code></a> and
<a href="sus-mem-Move.html"><code>Move&lt;E&gt;</code></a> are satisfied.</p>
<p>If <code>T</code> and <code>E</code> can be trivially move-assigned, then <code>Result&lt;T, E&gt;</code> can
also be trivially move-assigned. When trivially-moved, the <code>Result</code> is
copied on move, and the moved-from Result is unchanged but should still
not be used thereafter without reinitializing it.</p>

        </div>
      </div>
    </div>
  </div>
</body>
