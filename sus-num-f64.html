<!DOCTYPE html>

<head>
  <title>
    sus::num::f64
  </title>
  <link rel="stylesheet" href="subdoc-test-style.css">
</head>

<body>
  <div class="type record struct">
    <div class="section overview">
      <div class="section-header">
        <span>
          Struct
        </span>
        <a class="project-name" href="global-namespace.html">Subspace</a>
        <span class="namespace-dots">::</span>
        <a class="namespace-name" href="sus.html">sus</a>
        <span class="namespace-dots">::</span>
        <a class="namespace-name" href="sus-num.html">num</a>
        <span class="namespace-dots">::</span>
        <a class="type-name" href="#">f64</a>
      </div>
      <div class="type-signature">
        <span class="struct">
          struct
        </span>
        <span class="type-name">
          f64
        </span>
        <span class="final">
          final
        </span>
        <div class="record-body">
          { ... };
        </div>
      </div>
      <div class="description long">
        <p>A 64-bit floating point type (specifically, this type holds the same values
as the <code>double</code> type specified by the C++ standard).</p>
<p>This type is very similar to <a href="sus-num-f32.html"><code>f32</code></a>, but has increased precision by using
twice as many bits.</p>
<p>See the <a href="sus-num.html">namespace level documentation</a> for more.</p>

      </div>
    </div>
    <div class="section fields static">
      <div class="section-header">
        Static Data Members
      </div>
      <div class="section-items">
        <div class="section-item">
          <div class="item-name member-signature">
            <span class="static">
              static
            </span>
            <span class="const">
              const
            </span>
            <a class="type-name" title="struct u32" href="sus-num-u32.html">u32</a>
            <a class="field-name" name="field.DIGITS" href="#field.DIGITS">DIGITS</a>
          </div>
          <div class="description long">
            <p>Approximate number of significant digits in base 10.</p>

          </div>
        </div>
        <div class="section-item">
          <div class="item-name member-signature">
            <span class="static">
              static
            </span>
            <span class="const">
              const
            </span>
            <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a>
            <a class="field-name" name="field.EPSILON" href="#field.EPSILON">EPSILON</a>
          </div>
          <div class="description long">
            <p>Machine epsilon value for <a href="sus-num-f64.html"><code>f64</code></a>.</p>
<p>This is the difference between 1.0 and the next larger representable
number.</p>

          </div>
        </div>
        <div class="section-item">
          <div class="item-name member-signature">
            <span class="static">
              static
            </span>
            <span class="const">
              const
            </span>
            <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a>
            <a class="field-name" name="field.INFINITY" href="#field.INFINITY">INFINITY</a>
          </div>
          <div class="description long">
            <p>Infinity.</p>

          </div>
        </div>
        <div class="section-item">
          <div class="item-name member-signature">
            <span class="static">
              static
            </span>
            <span class="const">
              const
            </span>
            <a class="type-name" title="struct u32" href="sus-num-u32.html">u32</a>
            <a class="field-name" name="field.MANTISSA_DIGITS" href="#field.MANTISSA_DIGITS">MANTISSA_DIGITS</a>
          </div>
          <div class="description long">
            <p>Approximate number of significant digits in base 2.</p>

          </div>
        </div>
        <div class="section-item">
          <div class="item-name member-signature">
            <span class="static">
              static
            </span>
            <span class="const">
              const
            </span>
            <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a>
            <a class="field-name" name="field.MAX" href="#field.MAX">MAX</a>
          </div>
          <div class="description long">
            <p>Largest finite <a href="sus-num-f64.html"><code>f64</code></a>.</p>

          </div>
        </div>
        <div class="section-item">
          <div class="item-name member-signature">
            <span class="static">
              static
            </span>
            <span class="const">
              const
            </span>
            <a class="type-name" title="struct i32" href="sus-num-i32.html">i32</a>
            <a class="field-name" name="field.MAX_10_EXP" href="#field.MAX_10_EXP">MAX_10_EXP</a>
          </div>
          <div class="description long">
            <p>Maximum possible power of 10 exponent.</p>

          </div>
        </div>
        <div class="section-item">
          <div class="item-name member-signature">
            <span class="static">
              static
            </span>
            <span class="const">
              const
            </span>
            <a class="type-name" title="struct i32" href="sus-num-i32.html">i32</a>
            <a class="field-name" name="field.MAX_EXP" href="#field.MAX_EXP">MAX_EXP</a>
          </div>
          <div class="description long">
            <p>Maximum possible power of 2 exponent.</p>

          </div>
        </div>
        <div class="section-item">
          <div class="item-name member-signature">
            <span class="static">
              static
            </span>
            <span class="const">
              const
            </span>
            double
            <a class="field-name" name="field.MAX_PRIMITIVE" href="#field.MAX_PRIMITIVE">MAX_PRIMITIVE</a>
          </div>
          <div class="description long">
            <p>Largest finite primitive value.</p>

          </div>
        </div>
        <div class="section-item">
          <div class="item-name member-signature">
            <span class="static">
              static
            </span>
            <span class="const">
              const
            </span>
            <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a>
            <a class="field-name" name="field.MIN" href="#field.MIN">MIN</a>
          </div>
          <div class="description long">
            <p>Smallest finite <a href="sus-num-f64.html"><code>f64</code></a>.</p>

          </div>
        </div>
        <div class="section-item">
          <div class="item-name member-signature">
            <span class="static">
              static
            </span>
            <span class="const">
              const
            </span>
            <a class="type-name" title="struct i32" href="sus-num-i32.html">i32</a>
            <a class="field-name" name="field.MIN_10_EXP" href="#field.MIN_10_EXP">MIN_10_EXP</a>
          </div>
          <div class="description long">
            <p>Minimum possible normal power of 10 exponent.</p>

          </div>
        </div>
        <div class="section-item">
          <div class="item-name member-signature">
            <span class="static">
              static
            </span>
            <span class="const">
              const
            </span>
            <a class="type-name" title="struct i32" href="sus-num-i32.html">i32</a>
            <a class="field-name" name="field.MIN_EXP" href="#field.MIN_EXP">MIN_EXP</a>
          </div>
          <div class="description long">
            <p>One greater than the minimum possible normal power of 2 exponent.</p>

          </div>
        </div>
        <div class="section-item">
          <div class="item-name member-signature">
            <span class="static">
              static
            </span>
            <span class="const">
              const
            </span>
            <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a>
            <a class="field-name" name="field.MIN_POSITIVE" href="#field.MIN_POSITIVE">MIN_POSITIVE</a>
          </div>
          <div class="description long">
            <p>Smallest positive normal <a href="sus-num-f64.html"><code>f64</code></a> value.</p>

          </div>
        </div>
        <div class="section-item">
          <div class="item-name member-signature">
            <span class="static">
              static
            </span>
            <span class="const">
              const
            </span>
            double
            <a class="field-name" name="field.MIN_PRIMITIVE" href="#field.MIN_PRIMITIVE">MIN_PRIMITIVE</a>
          </div>
          <div class="description long">
            <p>Smallest finite primitive value.</p>

          </div>
        </div>
        <div class="section-item">
          <div class="item-name member-signature">
            <span class="static">
              static
            </span>
            <span class="const">
              const
            </span>
            <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a>
            <a class="field-name" name="field.NAN" href="#field.NAN">NAN</a>
          </div>
          <div class="description long">
            <p>Not a Number (NaN).</p>
<p>Note that IEEE-745 doesn't define just a single NaN value; a plethora of
bit patterns are considered to be NaN. Furthermore, the standard makes a
difference between a &quot;signaling&quot; and a &quot;quiet&quot; NaN, and allows inspecting
its &quot;payload&quot; (the unspecified bits in the bit pattern). This constant
isn't guaranteed to equal to any specific NaN bitpattern, and the
stability of its representation over Subspace versions and target
platforms isn't guaranteed.</p>
<p>This value is not constexpr because the value can differ in a constexpr
evaluation context from a runtime context, leading to bugs.</p>

          </div>
        </div>
        <div class="section-item">
          <div class="item-name member-signature">
            <span class="static">
              static
            </span>
            <span class="const">
              const
            </span>
            <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a>
            <a class="field-name" name="field.NEG_INFINITY" href="#field.NEG_INFINITY">NEG_INFINITY</a>
          </div>
          <div class="description long">
            <p>Negative infinity.</p>

          </div>
        </div>
        <div class="section-item">
          <div class="item-name member-signature">
            <span class="static">
              static
            </span>
            <span class="const">
              const
            </span>
            <a class="type-name" title="struct u32" href="sus-num-u32.html">u32</a>
            <a class="field-name" name="field.RADIX" href="#field.RADIX">RADIX</a>
          </div>
          <div class="description long">
            <p>The radix or base of the internal representation of
<a href="sus-num-f64.html"><code>f64</code></a>.</p>

          </div>
        </div>
      </div>
    </div>
    <div class="section methods static">
      <div class="section-header">
        Static Methods
      </div>
      <div class="section-items">
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><div class="template">template &lt;class P&gt;</div><a class="function-name" name="method.f64.ctor.from_primitive" href="sus-num-f64.html#method.f64.ctor.from_primitive">f64</a>(P v)</div>
          </div>
        </div>
        <div class="description long">
          <p>Construction from primitive types where no bits are lost.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><div class="template">template &lt;class F&gt;</div><a class="function-name" name="method.f64.ctor.from_float" href="sus-num-f64.html#method.f64.ctor.from_float">f64</a>(F v)</div>
          </div>
        </div>
        <div class="description long">
          <p>Construction from floating point types where no bits are lost.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><a class="function-name" name="method.f64.ctor.default" href="sus-num-f64.html#method.f64.ctor.default">f64</a>()</div>
          </div>
        </div>
        <div class="description long">
          <p>Default constructor, which sets the value to 0.</p>
<p>Satisfies the <a href="sus-construct-Default.html"><code>Default</code></a> concept.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><div class="template">template &lt;class F&gt;</div><span class="static">static</span><span class="function-auto">auto</span><a class="function-name" name="method.from.from.float" href="sus-num-f64.html#method.from.from.float">from</a>(F f) -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Construction from floating point types where no bits are lost.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><div class="template">template &lt;class F&gt;</div><span class="static">static</span><span class="function-auto">auto</span><a class="function-name" name="method.from.from.primitivefloat" href="sus-num-f64.html#method.from.from.primitivefloat">from</a>(F f) -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Construction from primitive floating point types where no bits are lost.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="static">static</span><span class="function-auto">auto</span><a class="function-name" name="method.from_be_bytes" href="sus-num-f64.html#method.from_be_bytes">from_be_bytes</a>(<a class="type-name" title="const ::sus::collections::Array&lt;u8, ::sus::mem::size_of&lt;double&gt;()&gt; &" href="sus-collections-Array.html">Array&lt;u8, ::sus::mem::size_of&lt;double&gt;()&gt; &</a> bytes) -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Create a floating point value from its representation as a byte array in
big endian.</p>
<p>See <a href="#method.from_bits"><code>from_bits</code></a> for why this function is not
constexpr.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="static">static</span><span class="function-auto">auto</span><a class="function-name" name="method.from_bits" href="sus-num-f64.html#method.from_bits">from_bits</a>(<a class="type-name" title="struct u64" href="sus-num-u64.html">u64</a> v) -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Raw transmutation from <code>##_unsigned##</code>.</p>
<p>This is identical to <a href="https://en.cppreference.com/w/cpp/numeric/bit_cast"><code>std::bit_cast&lt;f32, u32&gt;</code></a>, or
<code>std::bit_cast&lt;f64, u64&gt;</code>. It turns out this is incredibly portable, for two
reasons:</p>
<ul>
<li>Floats and Ints have the same endianness on all modern platforms.</li>
<li>IEEE 754 very precisely specifies the bit layout of floats.</li>
</ul>
<p>However there is one caveat: prior to the 2008 version of IEEE 754, how to
interpret the NaN signaling bit wasn’t actually specified. Most platforms
(notably x86 and ARM) picked the interpretation that was ultimately
standardized in 2008, but some didn’t (notably MIPS). As a result, all
signaling NaNs on MIPS are quiet NaNs on x86, and vice-versa.</p>
<p>Rather than trying to preserve signaling-ness cross-platform, this
implementation favors preserving the exact bits. This means that any
payloads encoded in NaNs will be preserved even if the result of this method
is sent over the network from an x86 machine to a MIPS one.</p>
<p>If the results of this method are only manipulated by the same architecture
that produced them, then there is no portability concern.</p>
<p>If the input isn’t NaN, then there is no portability concern.</p>
<p>If you don’t care about signalingness (very likely), then there is no
portability concern.</p>
<p>Note that this function is distinct from <code>Transmogrify</code> casting, which
attempts to preserve the <em>numeric</em> value, and not the bitwise value.</p>
<h1><a name="examples" href="#examples">Examples</a></h1>
<pre><code>auto v = f32::from_bits(0x41480000);
sus::check!(v, 12.5);
</code></pre>
<p>This function is not constexpr, as converting a NaN does not preserve the
exact bits in a constexpr context.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="static">static</span><span class="function-auto">auto</span><a class="function-name" name="method.from_le_bytes" href="sus-num-f64.html#method.from_le_bytes">from_le_bytes</a>(<a class="type-name" title="const ::sus::collections::Array&lt;u8, ::sus::mem::size_of&lt;double&gt;()&gt; &" href="sus-collections-Array.html">Array&lt;u8, ::sus::mem::size_of&lt;double&gt;()&gt; &</a> bytes) -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Create a floating point value from its representation as a byte array in
big endian.</p>
<p>See <a href="#method.from_bits"><code>from_bits</code></a> for why this function is not
constexpr.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="static">static</span><span class="function-auto">auto</span><a class="function-name" name="method.from_ne_bytes" href="sus-num-f64.html#method.from_ne_bytes">from_ne_bytes</a>(<a class="type-name" title="const ::sus::collections::Array&lt;u8, ::sus::mem::size_of&lt;double&gt;()&gt; &" href="sus-collections-Array.html">Array&lt;u8, ::sus::mem::size_of&lt;double&gt;()&gt; &</a> bytes) -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Create a floating point value from its representation as a byte array in
native endian.</p>
<p>As the target platform's native endianness is used, portable code likely
wants to use <a href="#method.from_be_bytes"><code>from_be_bytes</code></a> or
<a href="#method.from_le_bytes"><code>from_le_bytes</code></a>, as appropriate instead.</p>
<p>See <a href="#method.from_bits"><code>from_bits</code></a> for why this function is not
constexpr.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><div class="template">template &lt;class it:auto&gt;</div><span class="static">static</span><span class="function-auto">auto</span><a class="function-name" name="method.from_product" href="sus-num-f64.html#method.from_product">from_product</a>(Iterator&lt;f64&gt; auto && it) -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Constructs a <a href="sus-num-f64.html"><code>f64 </code></a> from an <code>Iterator</code> by
computing the product of all elements in the iterator.</p>
<p>This method should rarely be called directly, as it is used to satisfy the
<a href="sus-iter-Product.html"><code>Product</code></a> concept so that
<a href="sus-iter-IteratorBase.html#method.product"><code>Iterator::product()</code></a> can be
called for iterators over <a href="sus-num-f64.html"><code>f64 </code></a>.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><div class="template">template &lt;class it:auto&gt;</div><span class="static">static</span><span class="function-auto">auto</span><a class="function-name" name="method.from_sum" href="sus-num-f64.html#method.from_sum">from_sum</a>(Iterator&lt;f64&gt; auto && it) -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Constructs a <a href="sus-num-f64.html"><code>f64 </code></a> from an
<a href="sus-iter-Iterator.html"><code>Iterator</code></a> by computing the sum of all elements in
the iterator.</p>
<p>This method should rarely be called directly, as it is used to satisfy the
<a href="sus-iter-Sum.html"><code>Sum</code></a> concept so that
<a href="sus-iter-IteratorBase.html#method.sum"><code>Iterator::sum()</code></a> can be called for
iterators over <a href="sus-num-f64.html"><code>f64 </code></a>.</p>

        </div>
      </div>
    </div>
    <div class="section methods nonstatic">
      <div class="section-header">
        Methods
      </div>
      <div class="section-items">
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.abs" href="sus-num-f64.html#method.abs">abs</a>() const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.acos" href="sus-num-f64.html#method.acos">acos</a>() const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Computes the arccosine of a number. Return value is in radians in the
range [0, pi] or NaN if the number is outside the range [-1, 1].</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.acosh" href="sus-num-f64.html#method.acosh">acosh</a>() const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Inverse hyperbolic cosine function, or NaN if the number is less than
-1.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.asin" href="sus-num-f64.html#method.asin">asin</a>() const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Computes the arcsine of a number. Return value is in radians in the
range [-pi/2, pi/2] or NaN if the number is outside the range [-1, 1].</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.asinh" href="sus-num-f64.html#method.asinh">asinh</a>() const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Inverse hyperbolic sine function.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.atan" href="sus-num-f64.html#method.atan">atan</a>() const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Computes the arctangent of a number. Return value is in radians in the
range [-pi/2, pi/2];</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.atan2" href="sus-num-f64.html#method.atan2">atan2</a>(<a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a> other) const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Computes the four quadrant arctangent of self (y) and other (x) in
radians.</p>
<ul>
<li>x = 0, y = 0: 0</li>
<li>x &gt;= 0: arctan(y/x) -&gt; [-pi/2, pi/2]</li>
<li>y &gt;= 0: arctan(y/x) + pi -&gt; (pi/2, pi]</li>
<li>y &lt; 0: arctan(y/x) - pi -&gt; (-pi, -pi/2)</li>
</ul>
<p>Returns NaN if both <code>self</code> and <code>other</code> are 0.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.atanh" href="sus-num-f64.html#method.atanh">atanh</a>() const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Inverse hyperbolic tangent function.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.cbrt" href="sus-num-f64.html#method.cbrt">cbrt</a>() const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Returns the cube root of a number.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.ceil" href="sus-num-f64.html#method.ceil">ceil</a>() const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Returns the smallest integer greater than or equal to self.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.clamp" href="sus-num-f64.html#method.clamp">clamp</a>(<a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a> min, <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a> max) const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Restrict a value to a certain interval unless it is NaN.</p>
<p>Returns max if self is greater than max, and min if self is less than
min. Otherwise this returns self.</p>
<p>Note that this function returns NaN if the initial value was NaN as well.</p>
<h1><a name="panics" href="#panics">Panics</a></h1>
<p>Panics if min &gt; max, min is NaN, or max is NaN.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.classify" href="sus-num-f64.html#method.classify">classify</a>() const& -&gt; FpCategory</div>
          </div>
        </div>
        <div class="description long">
          <p>Returns the floating point category of the number.</p>
<p>If only one property is going to be tested, it is generally faster to use
the specific predicate instead.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.copysign" href="sus-num-f64.html#method.copysign">copysign</a>(<a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a> sign) const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Returns a number composed of the magnitude of self and the sign of sign.</p>
<p>Equal to self if the sign of self and sign are the same, otherwise equal
to -self. If self is a NaN, then a NaN with the sign bit of sign is
returned. Note, however, that conserving the sign bit on NaN across
arithmetical operations is not generally guaranteed.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.cos" href="sus-num-f64.html#method.cos">cos</a>() const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Computes the cosine of a number (in radians).</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.cosh" href="sus-num-f64.html#method.cosh">cosh</a>() const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Hyperbolic cosine function.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.div_euclid" href="sus-num-f64.html#method.div_euclid">div_euclid</a>(<a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a> rhs) const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Calculates Euclidean division, the matching method for
<a href="#method.rem_euclid"><code>rem_euclid</code></a>.</p>
<p>This computes the integer <code>n</code> such that <code>self = n * rhs + self.rem_euclid(rhs)</code>. In other words, the result is <code>self / rhs</code> rounded
to the integer <code>n</code> such that <code>self &gt;= n * rhs</code>.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.exp" href="sus-num-f64.html#method.exp">exp</a>() const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Returns <code>e^(self)</code>, (the exponential function).</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.exp2" href="sus-num-f64.html#method.exp2">exp2</a>() const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Returns <code>2^(self)</code>.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.exp_m1" href="sus-num-f64.html#method.exp_m1">exp_m1</a>() const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Returns <code>e^(self) - 1</code> in a way that is accurate even if the number is
close to zero.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.floor" href="sus-num-f64.html#method.floor">floor</a>() const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Returns the largest integer less than or equal to self.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.fract" href="sus-num-f64.html#method.fract">fract</a>() const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.hypot" href="sus-num-f64.html#method.hypot">hypot</a>(<a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a> other) const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Calculates the length of the hypotenuse of a right-angle triangle given
legs of length x and y.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.is_finite" href="sus-num-f64.html#method.is_finite">is_finite</a>() const& -&gt; bool</div>
          </div>
        </div>
        <div class="description long">
          <p>Returns true if this number is neither infinite nor NaN.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.is_infinite" href="sus-num-f64.html#method.is_infinite">is_infinite</a>() const& -&gt; bool</div>
          </div>
        </div>
        <div class="description long">
          <p>Returns true if this value is positive infinity or negative infinity,
and false otherwise.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.is_nan" href="sus-num-f64.html#method.is_nan">is_nan</a>() const& -&gt; bool</div>
          </div>
        </div>
        <div class="description long">
          <p>Returns true if this value is NaN.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.is_normal" href="sus-num-f64.html#method.is_normal">is_normal</a>() const& -&gt; bool</div>
          </div>
        </div>
        <div class="description long">
          <p>Returns true if the number is neither zero, infinite, subnormal, or NaN.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.is_sign_negative" href="sus-num-f64.html#method.is_sign_negative">is_sign_negative</a>() const& -&gt; bool</div>
          </div>
        </div>
        <div class="description long">
          <p>Returns true if self has a negative sign, including -0.0, NaNs with
negative sign bit and negative infinity.</p>
<p>Note that IEEE-745 doesn't assign any meaning to the sign bit in case of
a NaN</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.is_sign_positive" href="sus-num-f64.html#method.is_sign_positive">is_sign_positive</a>() const& -&gt; bool</div>
          </div>
        </div>
        <div class="description long">
          <p>Returns true if self has a positive sign, including +0.0, NaNs with
positive sign bit and positive infinity.</p>
<p>Note that IEEE-745 doesn't assign any meaning to the sign bit in case of
a NaN.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.is_subnormal" href="sus-num-f64.html#method.is_subnormal">is_subnormal</a>() const& -&gt; bool</div>
          </div>
        </div>
        <div class="description long">
          <p>Returns true if the number is subnormal.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.ln" href="sus-num-f64.html#method.ln">ln</a>() const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Returns the natural logarithm of the number.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.ln_1p" href="sus-num-f64.html#method.ln_1p">ln_1p</a>() const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Returns ln(1+n) (natural logarithm) more accurately than if the
operations were performed separately.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.log" href="sus-num-f64.html#method.log">log</a>(<a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a> base) const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Returns the logarithm of the number with respect to an arbitrary base.</p>
<p>The result might not be correctly rounded owing to implementation
details; self.log2() can produce more accurate results for base 2, and
self.log10() can produce more accurate results for base 10.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.log10" href="sus-num-f64.html#method.log10">log10</a>() const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Returns the base 10 logarithm of the number.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.log2" href="sus-num-f64.html#method.log2">log2</a>() const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Returns the base 2 logarithm of the number.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.max" href="sus-num-f64.html#method.max">max</a>(<a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a> other) const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Returns the maximum of the two numbers, ignoring NaN.</p>
<p>If one of the arguments is NaN, then the other argument is returned.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.min" href="sus-num-f64.html#method.min">min</a>(<a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a> other) const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Returns the minimum of the two numbers, ignoring NaN.</p>
<p>If one of the arguments is NaN, then the other argument is returned.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.mul_add" href="sus-num-f64.html#method.mul_add">mul_add</a>(<a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a> a, <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a> b) const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Fused multiply-add. Computes <code>(self * a) + b</code> with only one rounding
error, yielding a more accurate result than an unfused multiply-add.</p>
<p>Using mul_add may be more performant than an unfused multiply-add if the
target architecture has a dedicated fma CPU instruction. However, this is
not always true, and will be heavily dependent on designing algorithms
with specific target hardware in mind.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.next_toward" href="sus-num-f64.html#method.next_toward">next_toward</a>(<a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a> toward) const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Returns the next representable value of the float type after <code>self</code> in the
direction of <code>toward</code>. If <code>self == toward</code>, <code>toward</code> is returned. If either
<code>self</code> or <code>toward</code> is NAN, NAN is returned.</p>
<p>This is implemented by the
<a href="https://en.cppreference.com/w/c/numeric/math/nextafter">cmath</a> library, see
the documentation for details on errors.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.powf" href="sus-num-f64.html#method.powf">powf</a>(<a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a> n) const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Raises a number to a floating point power.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.powi" href="sus-num-f64.html#method.powi">powi</a>(<a class="type-name" title="struct i32" href="sus-num-i32.html">i32</a> n) const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Raises a number to an integer point power.</p>
<p>Using this function may be faster than using <a href="#method.powf"><code>powf</code></a>. It
might have a different sequence of rounding operations than
<a href="#method.powf"><code>powf</code></a>, so the results are not guaranteed to agree.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.recip" href="sus-num-f64.html#method.recip">recip</a>() const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Takes the reciprocal (inverse) of a number, <code>1/x</code>.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.rem_euclid" href="sus-num-f64.html#method.rem_euclid">rem_euclid</a>(<a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a> rhs) const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Calculates the least nonnegative remainder of <code>self (mod rhs)</code>.</p>
<p>In particular, the return value <code>r</code> satisfies <code>0.0 &lt;= r &lt; rhs.abs()</code> in
most cases. However, due to a floating point round-off error it can
result in <code>r == rhs.abs()</code>, violating the mathematical definition, if
<code>self</code> is much smaller than <code>rhs.abs()</code> in magnitude and <code>self &lt; 0.0</code>.
This result is not an element of the function's codomain, but it is the
closest floating point number in the real numbers and thus fulfills the
property <code>self == self.div_euclid(rhs) * rhs + self.rem_euclid(rhs)</code>
approximately.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.round" href="sus-num-f64.html#method.round">round</a>() const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Returns the nearest integer to itself, rounding half-way cases away from
<code>0.0</code>.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.signum" href="sus-num-f64.html#method.signum">signum</a>() const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Returns a number that represents the sign of self.</p>
<ul>
<li><code>1.0</code> if the number is positive, <code>+0.0</code> or <a href="#field.INFINITY"><code>INFINITY</code></a>.</li>
<li><code>-1.0</code> if the number is negative, <code>-0.0</code> or
<a href="#field.NEG_INFINITY"><code>NEG_INFINITY</code></a>.</li>
<li><code>NaN</code> if the number is <code>NaN</code>. The input value is returned exactly,
preserving signaling NaNs.</li>
</ul>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.sin" href="sus-num-f64.html#method.sin">sin</a>() const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Computes the sine of a number (in radians).</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.sinh" href="sus-num-f64.html#method.sinh">sinh</a>() const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Hyperbolic sine function.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.sqrt" href="sus-num-f64.html#method.sqrt">sqrt</a>() const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Returns the square root of a number.</p>
<p>Returns NaN if self is a negative number other than <code>-0.0</code>.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.tan" href="sus-num-f64.html#method.tan">tan</a>() const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Computes the tangent of a number (in radians).</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.tanh" href="sus-num-f64.html#method.tanh">tanh</a>() const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Hyperbolic tangent function.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.to_be_bytes" href="sus-num-f64.html#method.to_be_bytes">to_be_bytes</a>() const& -&gt; <a class="type-name" title="class ::sus::collections::Array&lt;u8, ::sus::mem::size_of&lt;double&gt;()&gt;" href="sus-collections-Array.html">Array&lt;u8, ::sus::mem::size_of&lt;double&gt;()&gt;</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Return the memory representation of this floating point number as a byte
array in big-endian (network) byte order.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.to_bits" href="sus-num-f64.html#method.to_bits">to_bits</a>() const& -&gt; <a class="type-name" title="struct u64" href="sus-num-u64.html">u64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Raw transmutation to ##UnsignedT##.</p>
<p>This is identical to <a href="https://en.cppreference.com/w/cpp/numeric/bit_cast"><code>std::bit_cast&lt;u32, f32&gt;</code></a>, or
<code>std::bit_cast&lt;u64, f64&gt;</code>.</p>
<p>See <code>from_bits()</code> for some discussion of the portability of this operation
(there are almost no issues).</p>
<p>Note that this function is distinct from <code>Transmogrify</code> casting, which
attempts to preserve the <em>numeric</em> value, and not the bitwise value.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.to_degrees" href="sus-num-f64.html#method.to_degrees">to_degrees</a>() const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Converts radians to degrees.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><div class="template">template &lt;class I&gt;</div><span class="function-auto">auto</span><a class="function-name" name="method.to_int_unchecked" href="sus-num-f64.html#method.to_int_unchecked">to_int_unchecked</a>(<a class="type-name" title="struct ::sus::marker::UnsafeFnMarker" href="sus-marker-UnsafeFnMarker.html">UnsafeFnMarker</a>) const& -&gt; I</div>
          </div>
        </div>
        <div class="description long">
          <p>Rounds toward zero and converts to any primitive integer type, assuming
that the value is finite and fits in that type.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.to_le_bytes" href="sus-num-f64.html#method.to_le_bytes">to_le_bytes</a>() const& -&gt; <a class="type-name" title="class ::sus::collections::Array&lt;u8, ::sus::mem::size_of&lt;double&gt;()&gt;" href="sus-collections-Array.html">Array&lt;u8, ::sus::mem::size_of&lt;double&gt;()&gt;</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Return the memory representation of this floating point number as a byte
array in little-endian byte order.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.to_ne_bytes" href="sus-num-f64.html#method.to_ne_bytes">to_ne_bytes</a>() const& -&gt; <a class="type-name" title="class ::sus::collections::Array&lt;u8, ::sus::mem::size_of&lt;double&gt;()&gt;" href="sus-collections-Array.html">Array&lt;u8, ::sus::mem::size_of&lt;double&gt;()&gt;</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Return the memory representation of this floating point number as a byte
array in native byte order.</p>
<p>As the target platform's native endianness is used, portable code should
use <a href="#method.to_be_bytes"><code>to_be_bytes</code></a> or
<a href="#method.to_le_bytes"><code>to_le_bytes</code></a>, as appropriate, instead.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.to_radians" href="sus-num-f64.html#method.to_radians">to_radians</a>() const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Converts degrees to radians.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.total_cmp" href="sus-num-f64.html#method.total_cmp">total_cmp</a>(<a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a> other) const& -&gt; weak_ordering</div>
          </div>
        </div>
        <div class="description long">
          <p>Return the ordering between <code>*this</code> and <code>other</code>.</p>
<p>Unlike the standard partial comparison between floating point numbers,
this comparison always produces an ordering in accordance to the
totalOrder predicate as defined in the IEEE 754 (2008 revision) floating
point standard. The values are ordered in the following sequence:</p>
<p>negative quiet NaN
negative signaling NaN
negative infinity
negative numbers
negative subnormal numbers
negative zero
positive zero
positive subnormal numbers
positive numbers
positive infinity
positive signaling NaN
positive quiet NaN.</p>
<p>The ordering established by this function does not always agree with the
<a href="sus-ops-PartialOrd.html"><code>PartialOrd</code></a> and <a href="sus-ops-Eq.html"><code>Eq</code></a>
implementations of <a href="sus-num-f64.html"><code>f64</code></a>. For example, they
consider negative and positive zero equal, while
<a href="#method.total_cmp"><code>total_cmp</code></a> doesn't.</p>
<p>The interpretation of the signaling NaN bit follows the definition in the
IEEE 754 standard, which may not match the interpretation by some of the
older, non-conformant (e.g. MIPS) hardware implementations.</p>
<h1><a name="why-does-this-method-satisfy-%60ord%60-and-not-%60strongord%60?" href="#why-does-this-method-satisfy-%60ord%60-and-not-%60strongord%60?">Why does this method satisfy <code>Ord</code> and not <code>StrongOrd</code>?</a></h1>
<p>This method returns
<a href="https://en.cppreference.com/w/cpp/utility/compare/weak_ordering"><code>std::weak_ordering</code></a>
which can be used in situations that require <a href="sus-ops-Ord.html"><code>Ord</code></a>
because different NaNs will be ordered equivalently.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.trunc" href="sus-num-f64.html#method.trunc">trunc</a>() const& -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Returns the integer part of self. This means that non-integer numbers
are always truncated towards zero.</p>

        </div>
      </div>
    </div>
    <div class="section methods conversion">
      <div class="section-header">
        Conversions
      </div>
      <div class="section-items">
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><div class="template">template &lt;class U&gt;</div><a class="function-name" name="method.operator U" href="sus-num-f64.html#method.operator U">operator U</a>() const</div>
          </div>
        </div>
        <div class="description long">
          <p>Conversion from the numeric type to a C++ primitive type.</p>
<p>This converts to floating point primitives which are at least as large as
the <a href="sus-num-f64.html"><code>f64</code></a>.</p>
<pre><code>auto d = double{3_f64};  // Compiles.
auto e = double(3_f64);  // Compiles.
double f = 3_f64;  // Compiles.

auto d = float{3_f64};  // Does not compile.
auto e = float(3_f64);  // Does not compile.
float f = 3_f64;  // Does not compile.
</code></pre>
<p>Potentially-lossy type conversions can be forced through the
<a href="sus-construct-Transmogrify.html"><code>Transmogrify</code></a> concept, such as
<code>sus::mog&lt;float&gt;(3_f64)</code> or <code>sus::mog&lt;f32&gt;(3_f64)</code>.</p>

        </div>
      </div>
    </div>
    <div class="section methods nonstatic">
      <div class="section-header">
        Operators
      </div>
      <div class="section-items">
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.operator%=" href="sus-num-f64.html#method.operator%=">operator%=</a>(<a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a> r) & -&gt; void</div>
          </div>
        </div>
        <div class="description long">
          <p>Satisfies the <a href="sus-num-RemAssign.html"><code>RemAssign&lt;f64&gt;</code></a> concept.</p>
<p>Assigns the remainder from the division of two floats.</p>
<p>The remainder has the same sign as the dividend and is computed as:
<code>l - (l / r).trunc() * r</code>.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.operator*=" href="sus-num-f64.html#method.operator*=">operator*=</a>(<a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a> r) & -&gt; void</div>
          </div>
        </div>
        <div class="description long">
          <p>Satisfies the <a href="sus-num-MulAssign.html"><code>MulAssign&lt;f64&gt;</code></a> concept.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.operator+=" href="sus-num-f64.html#method.operator+=">operator+=</a>(<a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a> r) & -&gt; void</div>
          </div>
        </div>
        <div class="description long">
          <p>Satisfies the <a href="sus-num-AddAssign.html"><code>AddAssign&lt;f64&gt;</code></a> concept.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.operator-" href="sus-num-f64.html#method.operator-">operator-</a>() const -&gt; <a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Satisfies the <a href="sus-num-Neg.html"><code>Neg&lt;f64&gt;</code></a> concept.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.operator-=" href="sus-num-f64.html#method.operator-=">operator-=</a>(<a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a> r) & -&gt; void</div>
          </div>
        </div>
        <div class="description long">
          <p>Satisfies the <a href="sus-num-SubAssign.html"><code>SubAssign&lt;f64&gt;</code></a> concept.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.operator/=" href="sus-num-f64.html#method.operator/=">operator/=</a>(<a class="type-name" title="struct f64" href="sus-num-f64.html">f64</a> r) & -&gt; void</div>
          </div>
        </div>
        <div class="description long">
          <p>Satisfies the <a href="sus-num-DivAssign.html"><code>DivAssign&lt;f64&gt;</code></a> concept.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><div class="template">template &lt;class F&gt;</div><span class="function-auto">auto</span><a class="function-name" name="method.operator=.assign.from_float" href="sus-num-f64.html#method.operator=.assign.from_float">operator=</a>(F v) -&gt; <a class="type-name" title="f64 &" href="sus-num-f64.html">f64 &</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Assignment from floating point types where no bits are lost.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><div class="template">template &lt;class P&gt;</div><span class="function-auto">auto</span><a class="function-name" name="method.operator=.assign.from_primitive" href="sus-num-f64.html#method.operator=.assign.from_primitive">operator=</a>(P v) -&gt; <a class="type-name" title="f64 &" href="sus-num-f64.html">f64 &</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Assignment from primitive types where no bits are lost.</p>

        </div>
      </div>
    </div>
    <div class="section fields nonstatic">
      <div class="section-header">
        Data Members
      </div>
      <div class="section-items">
        <div class="section-item">
          <div class="item-name member-signature">
            double
            <a class="field-name" name="field.primitive_value" href="#field.primitive_value">primitive_value</a>
          </div>
          <div class="description long">
            <p>The inner primitive value. Prefer to cast to the desired primitive type,
such as with <code>float{n}</code> for a numeric value <code>n</code>.</p>

          </div>
        </div>
      </div>
    </div>
  </div>
</body>
