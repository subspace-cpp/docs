<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type"></meta>
    <meta name="generator" content="subdoc"></meta>
    <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
    <meta property="og:type" content="website"></meta>
    <meta property="og:site_name" content="Subspace"></meta>
    <title>sus::option - Subspace</title>
    <meta property="og:title" content="sus::option - Subspace"></meta>
    <meta name="description" content="The Option type, and the some and none type-deduction constructor functions."></meta>
    <meta property="og:description" content="The Option type, and the some and none type-deduction constructor functions."></meta>
    <script src="https://unpkg.com/lunr/lunr.js"></script>
    <script src="./search_db.js"></script>
    <script>
      
        // Delayed loading of whatever was in the search box.
        var searchDelayLoad;

        // The search box's dynamic behaviour.
        document.addEventListener("keyup", e => {
          if (e.key === 's') {
            document.querySelector('.search-input').focus();
          }
          if (e.key === 'Escape') {
            document.querySelector('.search-input').blur();
            navigateToSearch(null);
            e.preventDefault();
          }
        });
        function navigateToSearch(query) {
          window.clearTimeout(searchDelayLoad);
          searchDelayLoad = null;

          let without_search =
              window.location.origin + window.location.pathname;
          if (query) {
            window.history.replaceState(null, "",
              without_search + "?" + `search=${query}`);
          } else {
            window.history.replaceState(null, "", without_search);
          }
          maybeShowSearchResults();
        }
        addEventListener("load", event => {
          document.querySelector(".search-input").oninput = (e) => {
            window.clearTimeout(searchDelayLoad);
            searchDelayLoad = window.setTimeout(() => {
              navigateToSearch(e.target.value);
            }, 1000);
          };
          document.querySelector(".search-input").onkeypress = (e) => {
            if (e.key == "Enter") {
              navigateToSearch(e.target.value);
              e.preventDefault();
            }
          };
          var searchPlaceholder;
          document.querySelector(".search-input").onfocus = (e) => {
            searchPlaceholder = e.target.placeholder;
            e.target.placeholder = "Type your search here.";
            navigateToSearch(e.target.value);
          };
          document.querySelector(".search-input").onblur = (e) => {
            e.target.placeholder = searchPlaceholder;
            searchPlaceholder = null;
          };
        });

        // Show or hide any DOM element.
        function showHide(selector, show) {
          if (show)
            document.querySelector(selector).classList.remove("hidden");
          else
            document.querySelector(selector).classList.add("hidden");
        }

        function searchQuery() {
          const params = new Proxy(
            new URLSearchParams(window.location.search), {
              get: (searchParams, prop) => searchParams.get(prop),
            }
          );
          return params.search;
        }

        // Showing search results.
        async function populateSearchResults(loaded) {
          const search_db = loaded.search_db;
          const idx = loaded.idx;

          // lunrjs treats `:` specially and `::` breaks the query syntax, so
          // just split into two words.
          const query = searchQuery().split("::").join(" ");
          let content = '';
          try {
            const results = idx.search(query);
            for (r of results) {
              const item = search_db[r.ref];

              const type = item.type;
              const url = item.url;
              const name = item.name;
              const full_name = item.full_name;
              const summmary = item.summary ? item.summary : "";

              content += `\
                <a class="search-results-link" href="${url}">
                  <span class="search-results-type"><div>${type}</div></span>\
                  <span class="search-results-name"><div>${full_name}</div></span>\
                  <span class="search-results-summary"><div>${summmary}</div></span>\
                </a>\
                `
            }
          } catch (err) {
            content +=
                `<div class="search-error">Search error: ${err.message}</div>`;
          }

          let content_elem = document.querySelector(".search-results-content");
          content_elem.innerHTML = content;

          let header_elem = document.querySelector(".search-results-header");
          header_elem.innerText = "Search results";
        }

        var cache_idx;

        // Searching via https://lunrjs.com.
        //
        // Load the JSON search database, which will be turned into a search
        // index. Returns an object with two fields:
        // - search_db: the contents of the search.json file.
        // - idx: the lunr search index.
        //   Documented at https://lunrjs.com/docs/lunr.Index.html.
        async function loadSearchIndex() {
          // This is not widely supported yet (not on Safari), so instead we
          // turned the json file into a js file that sets a global variable. :|
          //async function load_search_db() {
          //  let x = await import('./search.json', {
          //    with: {type: 'json'}
          //  });
          //  return x.default;
          //}

          async function load_idx(search_db) {
            let idx = lunr(function () {
              this.ref('index');
              this.field('name', {
                'boost': 2,
                editDistance: 0
              });
              this.field('full_name', {
                'boost': 2,
                editDistance: 2
              });
              this.field('split_name', {
                'boost': 0.5,
                editDistance: 2
              });

              // No stemming and no stopwords (like `into` and `from`).
              this.pipeline = new lunr.Pipeline();
              this.searchPipeline = new lunr.Pipeline();

              // Queries are split by these tokens.
              const splitBy = /(\s+|_+|(::)+)/
              this.use(builder => {
                function splitTokens(token) {
                  return token.toString().split(splitBy).map(str => {
                    return token.clone().update(() => { return str })
                  })
                }
                lunr.Pipeline.registerFunction(splitTokens, 'splitTokens')
                builder.searchPipeline.add(splitTokens)
              });

              search_db.forEach(item => {
                const weights = {
                  "concept": 3,
                  "class": 2,
                  "struct": 2,
                  "union": 2,
                  "function": 1.75,
                  "variable": 1.75,
                  "namespace": 1.2,
                  "method": 1,
                  "constructor": 1,
                  "macro": 1,
                  "project": 1,
                  "field": 0.9,
                  "conversion": 0.5,
                  "type alias": 0.5,
                  "concept alias": 0.5,
                  "function alias": 0.5,
                  "method alias": 0.5,
                  "enum value alias": 0.5,
                  "variable alias": 0.5,
                }
                let weight = weights[item.type];
                if (!weight) {
                  console.log(`WARNING: search item type ${item.type} ` +
                              `has no weight defined`);
                  weight = 1;
                }
                this.add(item, {
                  'boost': weight
                })
              }, this);
            });
            let out = {};
            out.search_db = search_db;
            out.idx = idx;
            return out;
          };

          if (!cache_idx) {
            cache_idx = await load_idx(g_search_db);
          }
          return cache_idx;
        }

        // If there's a search query, hide the other content and asynchronously
        // show the search results. Otherwise, hide search content and show the
        // rest immediately.
        function maybeShowSearchResults() {
          const query = searchQuery();
          if (query) {
            showHide(".main-content", false);

            let input = document.querySelector(".search-input");
            input.value = query;

            let header_elem = document.querySelector(".search-results-header");
            header_elem.innerText = "Loading search results...";

            let content_ele = document.querySelector(".search-results-content");
            content_ele.innerText = "";

            loadSearchIndex().then(populateSearchResults)
          } else {
            showHide(".main-content", true);

            let header_elem = document.querySelector(".search-results-header");
            header_elem.innerText = "";

            let content_ele = document.querySelector(".search-results-content");
            content_ele.innerText = "";
          }
        }

        
    </script>
    <link rel="stylesheet" href="subdoc-test-style.css">
    <link rel="icon" type="image/png" href="logo.png">
    <link rel="alternate icon" type="image/png" href="logo32.png">
    <meta property="og:image" content="logo.png"></meta>
  </head>

  <body>
    <nav class="topbar">
      <button class="sidebar-menu-button" onclick="let e = document.getElementsByClassName('sidebar')[0];e.classList.toggle('shown');">
        â˜°
      </button>
      <a class="topbar-logo-link" href="index.html"><div class="topbar-logo-border">
          <img class="topbar-logo" src="logo.png"></img>
        </div></a>
      <span class="topbar-text-area">
        <span class="topbar-title">
          <a href="#">option</a>
        </span>
      </span>
    </nav>
    <nav class="sidebar">
      <a class="sidebar-logo-link" href="index.html"><div class="sidebar-logo-border">
          <img class="sidebar-logo" src="logo.png"></img>
        </div></a>
      <div class="sidebar-pretitle sidebar-text">
        namespace
      </div>
      <div class="sidebar-title sidebar-text">
        <a href="#">option</a>
      </div>
      <div class="sidebar-subtitle sidebar-text">
      </div>
      <div class="sidebar-links sidebar-text">
        <ul>
          <li>
            <a class="sidebar-header" href="#classes">Classes</a>
          </li>
          <li>
            <a class="sidebar-item" href="sus-option-Option.html">Option</a>
          </li>
          <li>
            <a class="sidebar-item" href="sus-option-OptionIter.html">OptionIter</a>
          </li>
          <li>
            <a class="sidebar-header" href="#functions">Functions</a>
          </li>
          <li>
            <a class="sidebar-item" href="sus-option-fn.none.html">none</a>
          </li>
          <li>
            <a class="sidebar-item" href="sus-option-fn.some.html">some</a>
          </li>
          <li>
            <a class="sidebar-header" href="#operators">Operators</a>
          </li>
          <li>
            <a class="sidebar-item" href="sus-option-fn.operator_spaceship.html">operator&lt;=&gt;</a>
          </li>
          <li>
            <a class="sidebar-item" href="sus-option-fn.operator_eq.html">operator==</a>
          </li>
          <li>
            <a class="sidebar-header" href="#aliases-functions">Function Aliases</a>
          </li>
          <li>
            <a class="sidebar-item" href="sus-iter-fn.begin.html">begin</a>
          </li>
          <li>
            <a class="sidebar-item" href="sus-iter-fn.end.html">end</a>
          </li>
        </ul>
      </div>
    </nav>
    <main>
      <nav class="search-nav">
        <form class="search-form">
          <input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press 'S' to search...">
          </input>
        </form>
      </nav>
      <section class="search-results">
        <h1 class="search-results-header">
        </h1>
        <div class="search-results-content">
        </div>
      </section>
      <section class="main-content">
        <script>maybeShowSearchResults()</script>
        <div class="namespace">
          <div class="section overview">
            <h1 class="section-header">
              <div>
                <div class="src rightside"><a href="https://github.com/chromium/subspace/blob/main/sus/option/option.h#L444">source</a></div>
                <span>
                  Namespace
                </span>
                <a class="project-name" href="index.html">Subspace</a>
                <span class="namespace-dots">::</span>
                <a class="namespace-name" href="namespace.sus.html">sus</a>
                <span class="namespace-dots">::</span>
                <a class="namespace-name" href="#">option</a>
              </div>
            </h1>
            <div class="description long">
              <p>The <a href="sus-option-Option.html"><code>Option</code></a> type, and the
<a href="sus-option-fn.some.html"><code>some</code></a> and <a href="sus-option-fn.none.html"><code>none</code></a>
type-deduction constructor functions.</p>
<p>The <a href="sus-option-Option.html"><code>Option</code></a> type represents an optional value:
every <a href="sus-option-Option.html"><code>Option</code></a> is either Some and contains a
value, or None, and does not. It is similar to
<a href="https://en.cppreference.com/w/cpp/utility/optional"><code>std::optional</code></a> but
with some differences:</p>
<ul>
<li>Extensive vocabulary for combining <a href="sus-option-Option.html"><code>Option</code></a>s
together.</li>
<li>Safe defined behaviour (a panic) when unwrapping an empty
<a href="sus-option-Option.html"><code>Option</code></a>, with an
explicit unsafe backdoor
(<a href="sus-option-Option.html#method.unwrap_unchecked"><code>unwrap_unchecked</code></a>)
for when it is needed.</li>
<li>Avoid accidental expensive copies. Supports <a href="sus-mem-Copy.html"><code>Copy</code></a> if
the inner type is
<a href="sus-mem-Copy.html"><code>Copy</code></a> and <a href="sus-mem-Clone.html"><code>Clone</code></a> if the inner
type is <a href="sus-mem-Clone.html"><code>Clone</code></a>.</li>
<li>Provides <a href="sus-option-Option.html#method.take"><code>take()</code></a> to move a value
out of an lvalue <a href="sus-option-Option.html"><code>Option</code></a>, which mark the
lvalue as empty instead of leaving a moved-from value behind as with
<code>std::move(optional).value()</code>.</li>
<li>A custom message can be printed when trying to unwrap an empty
<a href="sus-option-Option.html"><code>Option</code></a>.</li>
<li>Subspace <a href="sus-namespace.iter.html">Iterator</a> integration.
<a href="sus-option-Option.html"><code>Option</code></a> can be iterated
over, acting like a single-element <a href="sus-namespace.collections.html">collection</a>,
which allows it to be chained together with other iterators, filtered,
etc.</li>
</ul>
<p><a href="sus-option-Option.html"><code>Option</code></a> types are very common, as they have a
number of uses:</p>
<ul>
<li>Initial values</li>
<li>Return values for functions that are not defined over their entire input
range (partial functions)</li>
<li>Return value for otherwise reporting simple errors, where <code>None</code> is
returned   on error.</li>
<li>Optional struct fields Struct fields that can be loaned or &quot;taken&quot;</li>
<li>Optional function arguments</li>
<li>Returning an optional reference to a member</li>
</ul>
<h1><a name="quick-start" href="#quick-start">Quick start</a></h1>
<p>When the type is known to the compiler, you can construct an
<a href="sus-option-Option.html"><code>Option</code></a> from a value without writing the full
type again, by using
<a href="sus-option-fn.some.html"><code>sus::some(x)</code></a> to make an
<a href="sus-option-Option.html"><code>Option</code></a> holding <code>x</code> or
<a href="sus-option-fn.none.html"><code>sus::none()</code></a> to make an empty
<a href="sus-option-Option.html"><code>Option</code></a>. If returning an
<a href="sus-option-Option.html"><code>Option</code></a> from a lambda, be sure to specify the
return type on the lambda to allow successful type deduction.</p>
<pre><code><span class="comment">// Returns Some(&quot;power!&quot;) if the input is over 9000, or None otherwise.</span>
<span class="keyword">auto</span> is_power <span class="punct">=</span> <span class="punct">[</span><span class="punct">]</span><span class="punct">(</span>i32 i<span class="punct">)</span> <span class="punct">-</span><span class="punct">&gt;</span> sus::Option<span class="punct">&lt;</span>std::string<span class="punct">&gt;</span> <span class="punct">{</span>
  <span class="keyword">if</span> <span class="punct">(</span>i <span class="punct">&gt;</span> 9000<span class="punct">)</span> <span class="keyword">return</span> sus::some<span class="punct">(</span><span class="string">&quot;power!&quot;</span><span class="punct">)</span><span class="punct">;</span>
  <span class="keyword">return</span> sus::none<span class="punct">(</span><span class="punct">)</span><span class="punct">;</span>
<span class="punct">}</span><span class="punct">;</span>
</code></pre>
<p>Use <a href="sus-option-Option.html#method.is_some"><code>is_some</code></a> and
<a href="sus-option-Option.html#method.is_none"><code>is_none</code></a> to see if the
<a href="sus-option-Option.html"><code>Option</code></a> is holding a value.</p>
<p>To immediately pull the inner value out of an
<a href="sus-option-Option.html"><code>Option</code></a> an an rvalue, use
<a href="sus-option-Option.html#method.unwrap"><code>unwrap</code></a>. If the
<a href="sus-option-Option.html"><code>Option</code></a> is an lvalue, use
<a href="sus-option-Option.html#method.as_value"><code>as_value</code></a> and
<a href="sus-option-Option.html#method.as_value_mut"><code>as_value_mut</code></a> to access the
inner value. Like
<a href="https://en.cppreference.com/w/cpp/utility/optional"><code>std::optional</code></a>,
<a href="sus-option-Option.html#method.operator*"><code>operator*</code></a> and
<a href="sus-option-Option.html#method.operator-%3E"><code>operator-&gt;</code></a> are also
available if preferred. However if doing this many times, consider doing
<a href="sus-option-Option.html#method.unwrap"><code>unwrap</code></a> a single time up front.</p>
<pre><code>sus_check<span class="punct">(</span>is_power<span class="punct">(</span>9001<span class="punct">)</span><span class="punct">.</span>unwrap<span class="punct">(</span><span class="punct">)</span> <span class="punct">=</span><span class="punct">=</span> <span class="string">&quot;power!&quot;</span><span class="punct">)</span><span class="punct">;</span>

<span class="keyword">if</span> <span class="punct">(</span>Option<span class="punct">&lt;</span>std::string<span class="punct">&gt;</span> lvalue <span class="punct">=</span> is_power<span class="punct">(</span>9001<span class="punct">)</span><span class="punct">;</span> lvalue<span class="punct">.</span>is_some<span class="punct">(</span><span class="punct">)</span><span class="punct">)</span>
  sus_check<span class="punct">(</span>lvalue<span class="punct">.</span>as_value<span class="punct">(</span><span class="punct">)</span> <span class="punct">=</span><span class="punct">=</span> <span class="string">&quot;power!&quot;</span><span class="punct">)</span><span class="punct">;</span>

sus_check<span class="punct">(</span>is_power<span class="punct">(</span>9000<span class="punct">)</span><span class="punct">.</span>unwrap_or<span class="punct">(</span><span class="string">&quot;unlucky&quot;</span><span class="punct">)</span> <span class="punct">=</span><span class="punct">=</span> <span class="string">&quot;unlucky&quot;</span><span class="punct">)</span><span class="punct">;</span>
</code></pre>
<p><a href="sus-option-Option.html"><code>Option&lt;const T&gt;</code></a> for non-reference-type <code>T</code>
is disallowed, as the <a href="sus-option-Option.html"><code>Option</code></a>
owns the <code>T</code> in that case and it ensures the
<a href="sus-option-Option.html"><code>Option</code></a> and the <code>T</code> are both
accessed with the same constness.</p>
<h1><a name="representation" href="#representation">Representation</a></h1>
<p>If a type <code>T</code> is a reference or satisties
<a href="sus-mem-NeverValueField.html"><code>NeverValueField</code></a>, then
<a href="sus-option-Option.html"><code>Option&lt;T&gt;</code></a> will have the same size as T and
will be internally represented as just a <code>T</code> (or <code>T*</code> in the case of
a reference <code>T&amp;</code>).</p>
<p>The following types <code>T</code>, when stored in an
<a href="sus-option-Option.html"><code>Option&lt;T&gt;</code></a>, will have the same
size as the original type <code>T</code>:</p>
<ul>
<li><code>const T&amp;</code> or <code>T&amp;</code> (have the same size as <code>const T*</code> or <code>T*</code>)</li>
<li><a href="sus-ptr-NonNull.html"><code>ptr::NonNull&lt;U&gt;</code></a></li>
<li><a href="sus-boxed-Box.html"><code>Box&lt;T&gt;</code></a></li>
<li><a href="sus-choice_type-Choice.html"><code>Choice</code></a></li>
</ul>
<p>This is called the &quot;NeverValueField optimization&quot;, but is also called the
<a href="https://doc.rust-lang.org/stable/std/option/index.html#representation">&quot;null pointer optimization&quot; or NPO in Rust</a>.</p>
<h1><a name="reference-parameters" href="#reference-parameters">Reference parameters</a></h1>
<p>As mentioned above <a href="sus-option-Option.html"><code>Option</code></a> type can hold a
reference, which allows code to use <code>Option&lt;const T&amp;&gt;</code> or <code>Option&lt;T&amp;&gt;</code>
as a function parameter in place of <code>const Option&lt;T&gt;&amp;</code> or <code>Option&lt;T&gt;&amp;</code>.
This can have a positive impact on compiler optimizations (and codegen
size) as the function is receiving the <a href="sus-option-Option.html"><code>Option</code></a>
by value and thus the compiler can reason locally about the
<a href="sus-option-Option.html"><code>Option</code></a>'s state. Otherwise
it needs to assume any function call can change the <code>const Option&lt;T&gt;&amp;</code> to
become empty/non-empty. This is a common optimization pitfall with
<a href="https://en.cppreference.com/w/cpp/utility/optional"><code>std::optional</code></a>.</p>
<p>As an example, this code is <a href="https://chromium-review.googlesource.com/c/chromium/src/+/4860473">optimized poorly</a>,
keeping a runtime check on
the <a href="sus-option-Option.html"><code>Option</code></a>. Global analysis could perhaps show it
not required, but it is beyond the view of the compiler.</p>
<pre><code><span class="keyword">void</span> Foo<span class="punct">(</span><span class="keyword">const</span> Option<span class="punct">&lt;</span>T<span class="punct">&gt;</span><span class="punct">&amp;</span> t<span class="punct">)</span> <span class="punct">{</span>
  <span class="keyword">if</span> <span class="punct">(</span>t<span class="punct">.</span>is_some<span class="punct">(</span><span class="punct">)</span><span class="punct">)</span> <span class="punct">{</span>
     A<span class="punct">(</span><span class="punct">)</span><span class="punct">;</span>  <span class="comment">// Compiler assumes `t` may be changed.</span>
     B<span class="punct">(</span>t<span class="punct">-</span><span class="punct">&gt;</span>thingy<span class="punct">)</span><span class="punct">;</span>  <span class="comment">// Compiler has to keep the check if `t` is Some.</span>
  <span class="punct">}</span>
<span class="punct">}</span>
</code></pre>
<p>Whereas here the compiler can elide runtime checks, and the parameter's size
is still the same as a pointer.
Use the <a href="sus-option-Option.html#method.as_ref"><code>as_ref</code></a> method to convert to
<code>Option&lt;const T&amp;&gt;</code> in the caller.</p>
<pre><code><span class="keyword">void</span> Foo<span class="punct">(</span>Option<span class="punct">&lt;</span><span class="keyword">const</span> T<span class="punct">&amp;</span><span class="punct">&gt;</span> t<span class="punct">)</span> <span class="punct">{</span>
  <span class="keyword">if</span> <span class="punct">(</span>t<span class="punct">.</span>is_some<span class="punct">(</span><span class="punct">)</span><span class="punct">)</span> <span class="punct">{</span>
     A<span class="punct">(</span><span class="punct">)</span><span class="punct">;</span>  <span class="comment">// Compiler knows `t` is not changed.</span>
     B<span class="punct">(</span>t<span class="punct">-</span><span class="punct">&gt;</span>thingy<span class="punct">)</span><span class="punct">;</span>  <span class="comment">// Compiler drops the redundant check if `t` is Some.</span>
  <span class="punct">}</span>
<span class="punct">}</span>
</code></pre>
<h1><a name="querying-the-variant" href="#querying-the-variant">Querying the variant</a></h1>
<p>The <a href="sus-option-Option.html#method.is_some"><code>is_some</code></a> and
<a href="sus-option-Option.html#method.is_none"><code>is_none</code></a> methods return
<code>true</code> if the <a href="sus-option-Option.html"><code>Option</code></a> is
holding a value or not, respectively.</p>
<h1><a name="adapters-for-working-with-lvalues" href="#adapters-for-working-with-lvalues">Adapters for working with lvalues</a></h1>
<p>The following methods allow you to create an
<a href="sus-option-Option.html"><code>Option</code></a> that refers to the value
held in an lvalue, without copying or moving from the lvalue:</p>
<ul>
<li><a href="sus-option-Option.html#method.as_ref"><code>as_ref</code></a> converts from a const
lvalue <a href="sus-option-Option.html"><code>Option&lt;T&gt;</code></a> to an rvalue
<a href="sus-option-Option.html"><code>Option&lt;const T&amp;&gt;</code></a>`.</li>
<li><a href="sus-option-Option.html#method.as_mut"><code>as_mut</code></a> converts from a mutable
lvalue <a href="sus-option-Option.html"><code>Option&lt;T&gt;</code></a> to an rvalue
<a href="sus-option-Option.html"><code>Option&lt;T&amp;&gt;</code></a>.</li>
<li><a href="sus-option-Option.html#method.take"><code>take</code></a> moves the element out of
the lvalue <a href="sus-option-Option.html"><code>Option&lt;T&gt;</code></a> into an rvalue
<a href="sus-option-Option.html"><code>Option&lt;T&gt;</code></a>, leaving the lvalue empty.</li>
</ul>
<h1><a name="extracting-the-contained-value" href="#extracting-the-contained-value">Extracting the contained value</a></h1>
<p>These methods extract the contained value in an <a href="sus-option-Option.html"><code>Option&lt;T&gt;</code></a> when it is
holding a value.</p>
<p>For working with the option as an lvalue:</p>
<ul>
<li><a href="sus-option-Option.html#method.as_value"><code>as_value</code></a> returns const
reference access to the inner value. It will panic with a generic
message when empty.</li>
<li><a href="sus-option-Option.html#method.as_value_mut"><code>as_value_mut</code></a> returns
mutable reference access to the inner value. It will panic with a
generic message when empty.</li>
<li><a href="sus-option-Option.html#method.operator*"><code>operator*</code></a> returns mutable
reference access to the inner value. It will panic with a generic message
when empty.</li>
<li><a href="sus-option-Option.html#method.operator-%3E"><code>operator-&gt;</code></a> returns mutable
pointer access to the inner value. It will panic with a generic message
when empty.</li>
</ul>
<p>For working with the option as an rvalue (when it returned from a function
call):</p>
<ul>
<li><a href="sus-option-Option.html#method.expect"><code>expect</code></a> moves and returns the
inner value. It will panic with a provided custom message when empty.</li>
<li><a href="sus-option-Option.html#method.unwrap"><code>unwrap</code></a> moves and returns the
inner value. It will panic with a generic message with empty.</li>
<li><a href="sus-option-Option.html#method.unwrap_or"><code>unwrap_or</code></a> moves and returns
the inner value. It will returns the provided default value instead when
empty.</li>
<li><a href="sus-option-Option.html#method.unwrap_or_default"><code>unwrap_or_default</code></a>
moves and returns the inner value. It will return the default value of
the type <code>T</code> (which must satisfy <a href="sus-construct-Default.html"><code>Default</code></a>)
when empty.</li>
<li><a href="sus-option-Option.html#method.unwrap_or_else"><code>unwrap_or_else</code></a> moves
and returns the inner value. It will return the result of evaluating
the provided function when empty.</li>
</ul>
<h1><a name="copying" href="#copying">Copying</a></h1>
<p>Most methods of <code>Option</code> act on an rvalue and consume the <code>Option</code> to
transform it into a new <code>Option</code> with a new value. This ensures that the
value inside an <code>Option</code> is moved while transforming it.</p>
<p>However, if <a href="sus-option-Option.html"><code>Option</code></a> is
<a href="sus-mem-Copy.html"><code>Copy</code></a>, then the majority of methods offer an
overload to be called as an lvalue, in which case the
<a href="sus-option-Option.html"><code>Option</code></a> will copy
itself, and its contained value, and perform the intended method on the copy
instead. This can have performance implications!</p>
<p>The unwrapping methods are excluded from this, and are only available on an
rvalue <a href="sus-option-Option.html"><code>Option</code></a> to avoid copying just to access
the inner value. To do that, access the inner value as a reference through
<a href="sus-option-Option.html#method.as_value"><code>as_value</code></a> and
<a href="sus-option-Option.html#method.as_value_mut"><code>as_value_mut</code></a> or through
<a href="sus-option-Option.html#method.operator*"><code>operator*</code></a> and
<a href="sus-option-Option.html#method.operator-%3E"><code>operator-&gt;</code></a>.</p>
<h1><a name="transforming-contained-values" href="#transforming-contained-values">Transforming contained values</a></h1>
<p>These methods transform <a href="sus-option-Option.html"><code>Option</code></a> to
<a href="sus-result-Result.html"><code>Result</code></a>:</p>
<ul>
<li><a href="sus-option-Option.html#method.ok_or"><code>ok_or</code></a> transforms <code>Some(v)</code>
to <code>Ok(v)</code>, and <code>None</code> to <code>Err(err)</code> using the provided default err value.</li>
<li><a href="sus-option-Option.html#method.ok_or_else"><code>ok_or_else</code></a> transforms
<code>Some(v)</code> to <code>Ok(v)</code>, and <code>None</code> to a value of <code>Err</code> using the
provided function.</li>
<li><a href="sus-option-Option.html#method.transpose"><code>transpose</code></a> transposes an
<a href="sus-option-Option.html"><code>Option</code></a> of a <a href="sus-result-Result.html"><code>Result</code></a>
into a <a href="sus-result-Result.html"><code>Result</code></a> of an
<a href="sus-option-Option.html"><code>Option</code></a>.</li>
</ul>
<p>These methods transform an option holding a value:</p>
<ul>
<li><a href="sus-option-Option.html#method.filter"><code>filter</code></a> calls the provided
predicate function on the contained value <code>t</code> if the
<a href="sus-option-Option.html"><code>Option</code></a> is <code>Some(t)</code>, and returns <code>Some(t)</code>
if the function returns <code>true</code>; otherwise, returns <code>None</code>.</li>
<li><a href="sus-option-Option.html#method.flatten"><code>flatten</code></a> removes one level
of nesting from an <code>Option&lt;Option&lt;T&gt;&gt;</code>.</li>
<li><a href="sus-option-Option.html#method.map"><code>map</code></a> transforms
<a href="sus-option-Option.html"><code>Option&lt;T&gt;</code></a> to
<a href="sus-option-Option.html"><code>Option&lt;U&gt;</code></a> by applying the provided
function to the contained value of <code>Some</code> and leaving <code>None</code> values
unchanged.</li>
</ul>
<p>These methods transform <a href="sus-option-Option.html"><code>Option&lt;T&gt;</code></a> to a value
of a possibly different type <code>U</code>:</p>
<ul>
<li><a href="sus-option-Option.html#method.map_or"><code>map_or</code></a> applies the provided
function to the contained value of <code>Some</code>, or returns the provided
default value if the
<a href="sus-option-Option.html"><code>Option</code></a> is <code>None</code>.</li>
<li><a href="sus-option-Option.html#method.map_or_else"><code>map_or_else</code></a> applies the
provided function to the contained value of <code>Some</code>, or returns the result
of evaluating the provided fallback function if the
<a href="sus-option-Option.html"><code>Option</code></a> is <code>None</code>.</li>
</ul>
<p>These methods combine the Some variants of two <code>Option</code> values:</p>
<ul>
<li><a href="sus-option-Option.html#method.zip"><code>zip</code></a> returns <code>Some(Tuple&lt;S, O&gt;(s, o)))</code> if the
<a href="sus-option-Option.html"><code>Option</code></a> is <code>Some(s)</code>
and the method is called with an <a href="sus-option-Option.html"><code>Option</code></a> value
of <code>Some(o)</code>; otherwise, returns <code>None</code></li>
<li>TODO: <a href="https://github.com/chromium/subspace/issues/341"><code>zip_with</code></a> calls
the provided
function <code>f</code> and returns <code>Some(f(s, o))</code> if the
<a href="sus-option-Option.html"><code>Option</code></a> is <code>Some(s)</code>
and the method is called with an <a href="sus-option-Option.html"><code>Option</code></a>
value of <code>Some(o)</code>; otherwise, returns <code>None</code>.</li>
</ul>
<h1><a name="boolean-operators" href="#boolean-operators">Boolean operators</a></h1>
<p>These methods treat the <a href="sus-option-Option.html"><code>Option</code></a> as a boolean value,
where <code>Some</code> acts like <code>true</code> and <code>None</code> acts like <code>false</code>. There are two
categories of these methods: ones that take an
<a href="sus-option-Option.html"><code>Option</code></a> as input, and ones
that take a function as input (to be lazily evaluated).</p>
<p>The <a href="sus-option-Option.html#method.and_that"><code>and_that</code></a>,
<a href="sus-option-Option.html#method.or_that"><code>or_that</code></a>,
and <a href="sus-option-Option.html#method.xor_that"><code>xor_that</code></a> methods take
another <a href="sus-option-Option.html"><code>Option</code></a> as input, and produce an
<a href="sus-option-Option.html"><code>Option</code></a> as output.
Only the <a href="sus-option-Option.html#method.and_that"><code>and_that</code></a>
method can produce an <a href="sus-option-Option.html"><code>Option&lt;U&gt;</code></a> value having a
different inner type <code>U</code> than <a href="sus-option-Option.html"><code>Option&lt;T&gt;</code></a>.</p>
<table>
<thead>
<tr>
<th>method</th>
<th>self</th>
<th>input</th>
<th>output</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="sus-option-Option.html#method.and_that"><code>and_that</code></a></td>
<td>None</td>
<td>(ignored)</td>
<td>None</td>
</tr>
<tr>
<td><a href="sus-option-Option.html#method.and_that"><code>and_that</code></a></td>
<td>Some(x)</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td><a href="sus-option-Option.html#method.and_that"><code>and_that</code></a></td>
<td>Some(x)</td>
<td>Some(y)</td>
<td>Some(y)</td>
</tr>
<tr>
<td><a href="sus-option-Option.html#method.or_that"><code>or_that</code></a></td>
<td>None</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td><a href="sus-option-Option.html#method.or_that"><code>or_that</code></a></td>
<td>None</td>
<td>Some(y)</td>
<td>Some(y)</td>
</tr>
<tr>
<td><a href="sus-option-Option.html#method.or_that"><code>or_that</code></a></td>
<td>Some(x)</td>
<td>(ignored)</td>
<td>Some(x)</td>
</tr>
<tr>
<td><a href="sus-option-Option.html#method.xor_that"><code>xor_that</code></a></td>
<td>None</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td><a href="sus-option-Option.html#method.xor_that"><code>xor_that</code></a></td>
<td>None</td>
<td>Some(y)</td>
<td>Some(y)</td>
</tr>
<tr>
<td><a href="sus-option-Option.html#method.xor_that"><code>xor_that</code></a></td>
<td>Some(x)</td>
<td>None</td>
<td>Some(x)</td>
</tr>
<tr>
<td><a href="sus-option-Option.html#method.xor_that"><code>xor_that</code></a></td>
<td>Some(x)</td>
<td>Some(y)</td>
<td>None</td>
</tr>
</tbody>
</table>
<p>The <a href="sus-option-Option.html#method.and_then"><code>and_then</code></a> and
<a href="sus-option-Option.html#method.or_else"><code>or_else</code></a> methods take a function
as input, and only evaluate the function when they need to produce a new
value. Only the <a href="sus-option-Option.html#method.and_then"><code>and_then</code></a> method
can produce an <a href="sus-option-Option.html"><code>Option&lt;U&gt;</code></a> value having a
different inner type <code>U</code> than <a href="sus-option-Option.html"><code>Option&lt;T&gt;</code></a>.</p>
<table>
<thead>
<tr>
<th>method</th>
<th>self</th>
<th>function input</th>
<th>function result</th>
<th>output</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="sus-option-Option.html#method.and_then"><code>and_then</code></a></td>
<td>None</td>
<td>(not provided)</td>
<td>(not evaluated)</td>
<td>None</td>
</tr>
<tr>
<td><a href="sus-option-Option.html#method.and_then"><code>and_then</code></a></td>
<td>Some(x)</td>
<td>x</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td><a href="sus-option-Option.html#method.and_then"><code>and_then</code></a></td>
<td>Some(x)</td>
<td>x</td>
<td>Some(y)</td>
<td>Some(y)</td>
</tr>
<tr>
<td><a href="sus-option-Option.html#method.or_else"><code>or_else</code></a></td>
<td>None</td>
<td>(not provided)</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td><a href="sus-option-Option.html#method.or_else"><code>or_else</code></a></td>
<td>None</td>
<td>(not provided)</td>
<td>Some(y)</td>
<td>Some(y)</td>
</tr>
<tr>
<td><a href="sus-option-Option.html#method.or_else"><code>or_else</code></a></td>
<td>Some(x)</td>
<td>(not provided)</td>
<td>(not evaluated)</td>
<td>Some(x)</td>
</tr>
</tbody>
</table>
<p>This is an example of using methods like
<a href="sus-option-Option.html#method.and_then"><code>and_then</code></a> and
<a href="sus-option-Option.html#method.or_that"><code>or_that</code></a> in a pipeline of
method calls. Early stages of the pipeline pass failure values (<code>None</code>)
through unchanged, and continue processing on success values (<code>Some</code>).
Toward the end, or substitutes an error message if it receives <code>None</code>.</p>
<pre><code><span class="keyword">auto</span> to_string <span class="punct">=</span> <span class="punct">[</span><span class="punct">]</span><span class="punct">(</span>u8 u<span class="punct">)</span> <span class="punct">-</span><span class="punct">&gt;</span> sus::Option<span class="punct">&lt;</span>std::string<span class="punct">&gt;</span> <span class="punct">{</span>
  <span class="keyword">switch</span> <span class="punct">(</span>uint8_t<span class="punct">{</span>u<span class="punct">}</span><span class="punct">)</span> <span class="punct">{</span>  <span class="comment">// switch requires a primitive.</span>
    <span class="keyword">case</span> 20u: <span class="keyword">return</span> sus::some<span class="punct">(</span><span class="string">&quot;foo&quot;</span><span class="punct">)</span><span class="punct">;</span>
    <span class="keyword">case</span> 42u: <span class="keyword">return</span> sus::some<span class="punct">(</span><span class="string">&quot;bar&quot;</span><span class="punct">)</span><span class="punct">;</span>
    <span class="keyword">default</span>: <span class="keyword">return</span> sus::none<span class="punct">(</span><span class="punct">)</span><span class="punct">;</span>
  <span class="punct">}</span>
<span class="punct">}</span><span class="punct">;</span>
<span class="keyword">auto</span> res <span class="punct">=</span>
    sus::Vec<span class="punct">&lt;</span>u8<span class="punct">&gt;</span><span class="punct">(</span>0_u8<span class="punct">,</span> 1_u8<span class="punct">,</span> 11_u8<span class="punct">,</span> 200_u8<span class="punct">,</span> 22_u8<span class="punct">)</span>
        <span class="punct">.</span>into_iter<span class="punct">(</span><span class="punct">)</span>
        <span class="punct">.</span>map<span class="punct">(</span><span class="punct">[</span><span class="punct">&amp;</span><span class="punct">]</span><span class="punct">(</span><span class="keyword">auto</span> x<span class="punct">)</span> <span class="punct">{</span>
          <span class="comment">// `checked_sub()` returns `None` on error.</span>
          <span class="keyword">return</span> x<span class="punct">.</span>checked_sub<span class="punct">(</span>1_u8<span class="punct">)</span>
              <span class="comment">// same with `checked_mul()`.</span>
              <span class="punct">.</span>and_then<span class="punct">(</span><span class="punct">[</span><span class="punct">]</span><span class="punct">(</span>u8 x<span class="punct">)</span> <span class="punct">{</span> <span class="keyword">return</span> x<span class="punct">.</span>checked_mul<span class="punct">(</span>2_u8<span class="punct">)</span><span class="punct">;</span> <span class="punct">}</span><span class="punct">)</span>
              <span class="comment">// `to_string` returns `None` on error.</span>
              <span class="punct">.</span>and_then<span class="punct">(</span><span class="punct">[</span><span class="punct">&amp;</span><span class="punct">]</span><span class="punct">(</span>u8 x<span class="punct">)</span> <span class="punct">{</span> <span class="keyword">return</span> to_string<span class="punct">(</span>x<span class="punct">)</span><span class="punct">;</span> <span class="punct">}</span><span class="punct">)</span>
              <span class="comment">// Substitute an error message if we have `None` so far.</span>
              <span class="punct">.</span>or_that<span class="punct">(</span>sus::some<span class="punct">(</span>std::string<span class="punct">(</span><span class="string">&quot;error!&quot;</span><span class="punct">)</span><span class="punct">)</span><span class="punct">)</span>
              <span class="comment">// Won't panic because we unconditionally used `Some` above.</span>
              <span class="punct">.</span>unwrap<span class="punct">(</span><span class="punct">)</span><span class="punct">;</span>
        <span class="punct">}</span><span class="punct">)</span>
        <span class="punct">.</span>collect<span class="punct">&lt;</span>Vec<span class="punct">&lt;</span>std::string<span class="punct">&gt;</span><span class="punct">&gt;</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span>
sus_check<span class="punct">(</span>res <span class="punct">=</span><span class="punct">=</span> sus::vec<span class="punct">(</span><span class="string">&quot;error!&quot;</span><span class="punct">,</span> <span class="string">&quot;error!&quot;</span><span class="punct">,</span> <span class="string">&quot;foo&quot;</span><span class="punct">,</span> <span class="string">&quot;error!&quot;</span><span class="punct">,</span> <span class="string">&quot;bar&quot;</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span>
</code></pre>
<h1><a name="restrictions-on-returning-references" href="#restrictions-on-returning-references">Restrictions on returning references</a></h1>
<p>Methods that return references are only callable on an rvalue
<a href="sus-option-Option.html"><code>Option</code></a> if the
<a href="sus-option-Option.html"><code>Option</code></a> is holding a reference. If the
<a href="sus-option-Option.html"><code>Option</code></a> is holding a non-reference
type, returning a reference from an rvalue
<a href="sus-option-Option.html"><code>Option</code></a> would be giving a reference to a
short-lived object which is a bugprone pattern in C++ leading to
memory-safety bugs.</p>

            </div>
          </div>
          <div class="section records classes">
            <h1 class="section-header">
              <a name="classes" href="#classes">Classes</a>
            </h1>
            <ul class="section-items item-table">
              <li class="section-item">
                <div class="item-name">
                  <div class="type-signature"><a class="type-name" href="sus-option-Option.html">Option</a></div>
                </div>
                <div class="description short">
                  <p>The <a href="sus-option-Option.html"><code>Option</code></a> type.</p>
                </div>
              </li>
              <li class="section-item">
                <div class="item-name">
                  <div class="type-signature"><a class="type-name" href="sus-option-OptionIter.html">OptionIter</a></div>
                </div>
                <div class="description short">
                  <p>An iterator over the element from an <a href="sus-option-Option.html"><code>Option</code></a>.</p>
                </div>
              </li>
            </ul>
          </div>
          <div class="section functions">
            <h1 class="section-header">
              <a name="functions" href="#functions">Functions</a>
            </h1>
            <ul class="section-items item-table">
              <li class="section-item">
                <div class="overload-set item-name">
                  <div class="overload">
                    <div class="function-signature"><a class="function-name" href="sus-option-fn.none.html">none</a></div>
                  </div>
                </div>
                <div class="description short">
                  <p>Used to construct an option with a None value.</p>
                </div>
              </li>
              <li class="section-item">
                <div class="overload-set item-name">
                  <div class="overload">
                    <div class="function-signature"><a class="function-name" href="sus-option-fn.some.html">some</a></div>
                  </div>
                </div>
                <div class="description short">
                  <p>Used to construct an option with a Some(t) value.</p>
                </div>
              </li>
            </ul>
          </div>
          <div class="section functions">
            <h1 class="section-header">
              <a name="operators" href="#operators">Operators</a>
            </h1>
            <ul class="section-items item-table">
              <li class="section-item">
                <div class="overload-set item-name">
                  <div class="overload">
                    <div class="function-signature"><a class="function-name" href="sus-option-fn.operator_spaceship.html">operator&lt;=&gt;</a></div>
                  </div>
                </div>
                <div class="description short">
                  <p>Compares two options. This function requires that <code>T</code> is ordered.
An empty option always compares less than a non-empty option.</p>
                </div>
              </li>
              <li class="section-item">
                <div class="overload-set item-name">
                  <div class="overload">
                    <div class="function-signature"><a class="function-name" href="sus-option-fn.operator_eq.html">operator==</a></div>
                  </div>
                </div>
                <div class="description short">
                  <p>Satisfies the <a href="sus-cmp-Eq.html"><code>Eq&lt;Option&lt;U&gt;&gt;</code></a> concept.</p>
                </div>
              </li>
            </ul>
          </div>
          <div class="section aliases functions">
            <h1 class="section-header">
              <a name="aliases-functions" href="#aliases-functions">Function Aliases</a>
            </h1>
            <ul class="section-items item-table">
              <li class="section-item">
                <div class="item-name">
                  <div class="type-signature"><a name="alias.begin"></a><a class="type-name" href="sus-iter-fn.begin.html">begin</a></div>
                </div>
                <div class="description short">
                  <p>Implicit for-ranged loop iteration via <a href="sus-option-Option.html#method.iter"><code>Option::iter</code></a>.</p>
                </div>
              </li>
              <li class="section-item">
                <div class="item-name">
                  <div class="type-signature"><a name="alias.end"></a><a class="type-name" href="sus-iter-fn.end.html">end</a></div>
                </div>
                <div class="description short">
                  <p>Implicit for-ranged loop iteration via <a href="sus-option-Option.html#method.iter"><code>Option::iter</code></a>.</p>
                </div>
              </li>
            </ul>
          </div>
        </div>
      </section>
    </main>
  </body>
</html>
