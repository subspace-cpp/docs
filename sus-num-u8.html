<!DOCTYPE html>

<head>
  <meta name="generator" content="subdoc"></meta>
  <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
  <title>sus::num::u8 - Subspace</title>
  <meta name="description" content="An 8-bit unsigned integer."></meta>
  <link rel="stylesheet" href="subdoc-test-style.css">
</head>

<body>
  <div class="type record struct">
    <div class="section overview">
      <div class="section-header">
        <span>
          Struct
        </span>
        <a class="project-name" href="index.html">Subspace</a>
        <span class="namespace-dots">::</span>
        <a class="namespace-name" href="namespace.sus.html">sus</a>
        <span class="namespace-dots">::</span>
        <a class="namespace-name" href="sus-namespace.num.html">num</a>
        <span class="namespace-dots">::</span>
        <a class="type-name" href="#">u8</a>
      </div>
      <div class="type-signature">
        <span class="struct">
          struct
        </span>
        <span class="type-name">
          u8
        </span>
        <span class="final">
          final
        </span>
        <div class="record-body">
          { ... };
        </div>
      </div>
      <div class="description long">
        <p>An 8-bit unsigned integer.</p>
<p>See the <a href="sus-num.html">namespace level documentation</a> for more.</p>

      </div>
    </div>
    <div class="section fields static">
      <div class="section-header">
        Static Data Members
      </div>
      <div class="section-items">
        <div class="section-item">
          <div class="item-name member-signature">
            <span class="static">
              static
            </span>
            <span class="const">
              const
            </span>
            <a class="type-name" title="struct u32" href="sus-num-u32.html">u32</a>
            <a class="field-name" name="field.BITS" href="#field.BITS">BITS</a>
          </div>
          <div class="description long">
            <p>The size of and <a href="sus-num-u8.html"><code>u8</code></a> in bits.</p>

          </div>
        </div>
        <div class="section-item">
          <div class="item-name member-signature">
            <span class="static">
              static
            </span>
            <span class="const">
              const
            </span>
            <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a>
            <a class="field-name" name="field.MAX" href="#field.MAX">MAX</a>
          </div>
          <div class="description long">
            <p>The largest value that can be represented by an
<a href="sus-num-u8.html"><code>u8</code></a>.</p>

          </div>
        </div>
        <div class="section-item">
          <div class="item-name member-signature">
            <span class="static">
              static
            </span>
            <span class="const">
              const
            </span>
            unsigned char
            <a class="field-name" name="field.MAX_PRIMITIVE" href="#field.MAX_PRIMITIVE">MAX_PRIMITIVE</a>
          </div>
          <div class="description long">
            <p>The largest value that can be represented by an
<a href="sus-num-u8.html"><code>u8</code></a>, as a native C++ primitive.</p>

          </div>
        </div>
        <div class="section-item">
          <div class="item-name member-signature">
            <span class="static">
              static
            </span>
            <span class="const">
              const
            </span>
            <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a>
            <a class="field-name" name="field.MIN" href="#field.MIN">MIN</a>
          </div>
          <div class="description long">
            <p>The smallest value that can be represented by an
<a href="sus-num-u8.html"><code>u8</code></a>.</p>

          </div>
        </div>
        <div class="section-item">
          <div class="item-name member-signature">
            <span class="static">
              static
            </span>
            <span class="const">
              const
            </span>
            unsigned char
            <a class="field-name" name="field.MIN_PRIMITIVE" href="#field.MIN_PRIMITIVE">MIN_PRIMITIVE</a>
          </div>
          <div class="description long">
            <p>The smallest value that can be represented by an
<a href="sus-num-u8.html"><code>u8</code></a>, as a native C++ primitive.</p>

          </div>
        </div>
      </div>
    </div>
    <div class="section methods static">
      <div class="section-header">
        Static Methods
      </div>
      <div class="section-items">
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><div class="template">template &lt;class P&gt;</div><a class="function-name" name="method.u8.ctor.unsigned.smallenum" href="sus-num-u8.html#method.u8.ctor.unsigned.smallenum">u8</a>(P v)</div>
          </div>
        </div>
        <div class="description long">
          <p>Construction from unsigned enum types where no bits are lost.</p>
<p>For conversions from types with a larger range use
<a href="#method.try_from"><code>try_from</code></a>. For lossy conversions use the
<a href="sus-construct-Transmogrify.html"><code>Transmogrify</code></a> concept with
<a href="sus-construct-fn.mog.html"><code>sus::mog&lt;u8&gt;()</code></a>.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><div class="template">template &lt;class P&gt;</div><a class="function-name" name="method.u8.ctor.unsigned.small.primitive" href="sus-num-u8.html#method.u8.ctor.unsigned.small.primitive">u8</a>(P v)</div>
          </div>
        </div>
        <div class="description long">
          <p>Construction from unsigned primitive types where no bits are lost.</p>
<p>For conversions from types with a larger range use
<a href="#method.try_from"><code>try_from</code></a>. For lossy conversions use the
<a href="sus-construct-Transmogrify.html"><code>Transmogrify</code></a> concept with
<a href="sus-construct-fn.mog.html"><code>sus::mog&lt;u8&gt;()</code></a>.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><div class="template">template &lt;class U&gt;</div><a class="function-name" name="method.u8.ctor.unsigned.small.typed" href="sus-num-u8.html#method.u8.ctor.unsigned.small.typed">u8</a>(U v)</div>
          </div>
        </div>
        <div class="description long">
          <p>Construction from unsigned types where no bits are lost.</p>
<p>For conversions from types with a larger range use
<a href="#method.try_from"><code>try_from</code></a>. For lossy conversions use the
<a href="sus-construct-Transmogrify.html"><code>Transmogrify</code></a> concept with
<a href="sus-construct-fn.mog.html"><code>sus::mog&lt;u8&gt;()</code></a>.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><a class="function-name" name="method.u8.ctor.default" href="sus-num-u8.html#method.u8.ctor.default">u8</a>()</div>
          </div>
        </div>
        <div class="description long">
          <p>Default constructor, which sets the integer to 0.</p>
<p>Satisfies the <a href="sus-construct-Default.html"><code>Default</code></a> concept.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><div class="template">template &lt;class P&gt;</div><a class="function-name" name="method.u8.ctor.unsigned.smallenumclass" href="sus-num-u8.html#method.u8.ctor.unsigned.smallenumclass">u8</a>(P v)</div>
          </div>
        </div>
        <div class="description long">
          <p>Construction from unsigned enum class types where no bits are lost.</p>
<p>For conversions from types with a larger range use
<a href="#method.try_from"><code>try_from</code></a>. For lossy conversions use the
<a href="sus-construct-Transmogrify.html"><code>Transmogrify</code></a> concept with
<a href="sus-construct-fn.mog.html"><code>sus::mog&lt;u8&gt;()</code></a>.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><div class="template">template &lt;class U&gt;</div><span class="static">static</span><span class="function-auto">auto</span><a class="function-name" name="method.from.unsigned.from.unsigned" href="sus-num-u8.html#method.from.unsigned.from.unsigned">from</a>(U u) -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Constructs a u8 from an unsigned integer type (u8, u16, u32, etc)
where no bits are lost.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><div class="template">template &lt;class U&gt;</div><span class="static">static</span><span class="function-auto">auto</span><a class="function-name" name="method.from.unsigned.from.unsignedprimitive" href="sus-num-u8.html#method.from.unsigned.from.unsignedprimitive">from</a>(U u) -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Constructs a u8 from an unsigned primitive integer type (unsigned
int, unsigned long, etc) where no bits are lost.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><div class="template">template &lt;class U&gt;</div><span class="static">static</span><span class="function-auto">auto</span><a class="function-name" name="method.from.unsigned.from.unsignedenum" href="sus-num-u8.html#method.from.unsigned.from.unsignedenum">from</a>(U u) -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Constructs a u8 from an unsigned enum type (or enum class) where no
bits are lost.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="static">static</span><span class="function-auto">auto</span><a class="function-name" name="method.from_be" href="sus-num-u8.html#method.from_be">from_be</a>(<a class="type-name" title="const u8 &" href="sus-num-u8.html">const u8 &</a> x) -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Converts an integer from big endian to the target's endianness.</p>
<p>On big endian this is a no-op. On little endian the bytes are swapped.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="static">static</span><span class="function-auto">auto</span><a class="function-name" name="method.from_be_bytes" href="sus-num-u8.html#method.from_be_bytes">from_be_bytes</a>(Array&lt;u8, ::sus::mem::size_of&lt;uint8_t&gt;()&gt; & bytes) -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Create an integer value from its representation as a byte array in big
endian.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="static">static</span><span class="function-auto">auto</span><a class="function-name" name="method.from_le" href="sus-num-u8.html#method.from_le">from_le</a>(<a class="type-name" title="const u8 &" href="sus-num-u8.html">const u8 &</a> x) -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Converts an integer from little endian to the target's endianness.</p>
<p>On little endian this is a no-op. On big endian the bytes are swapped.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="static">static</span><span class="function-auto">auto</span><a class="function-name" name="method.from_le_bytes" href="sus-num-u8.html#method.from_le_bytes">from_le_bytes</a>(Array&lt;u8, ::sus::mem::size_of&lt;uint8_t&gt;()&gt; & bytes) -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Create an integer value from its representation as a byte array in little
endian.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="static">static</span><span class="function-auto">auto</span><a class="function-name" name="method.from_ne_bytes" href="sus-num-u8.html#method.from_ne_bytes">from_ne_bytes</a>(Array&lt;u8, ::sus::mem::size_of&lt;uint8_t&gt;()&gt; & bytes) -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Create an integer value from its memory representation as a byte array in
native endianness.</p>
<p>As the target platform's native endianness is used, portable code likely
wants to use <code>from_be_bytes()</code> or <code>from_le_bytes()</code>, as appropriate instead.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><div class="template">template &lt;class it:auto&gt;</div><span class="static">static</span><span class="function-auto">auto</span><a class="function-name" name="method.from_product" href="sus-num-u8.html#method.from_product">from_product</a>(Iterator&lt;u8&gt; auto && it) -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Constructs a u8 from an <code>Iterator</code> by computing the product of all
elements in the iterator.</p>
<p>This method should rarely be called directly, as it is used to satisfy the
<a href="sus-iter-Product.html"><code>Product</code></a> concept so that
<a href="sus-iter-IteratorBase.html#method.product"><code>Iterator::product()</code></a> can be
called for iterators over u8.</p>
<p>To handle overflow without panicing, instead of <code>iter.product()</code>, use
<code>iter.product&lt;OverflowInteger&lt;u8&gt;&gt;()</code>.</p>
<h1><a name="panics" href="#panics">Panics</a></h1>
<p>This method will panic if the product of all values overflows.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><div class="template">template &lt;class it:auto&gt;</div><span class="static">static</span><span class="function-auto">auto</span><a class="function-name" name="method.from_sum" href="sus-num-u8.html#method.from_sum">from_sum</a>(Iterator&lt;u8&gt; auto && it) -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Constructs a u8 from an <code>Iterator</code> by computing the sum of all
elements in the itertor.</p>
<p>This method should rarely be called directly, as it is used to satisfy the
<a href="sus-iter-Sum.html"><code>Sum</code></a> concept so that
<a href="sus-iter-IteratorBase.html#method.sum"><code>Iterator::sum()</code></a> can be called for
iterators over u8.</p>
<p>To handle overflow without panicing, instead of <code>iter.sum()</code>, use
<code>iter.sum&lt;OverflowInteger&lt;u8&gt;&gt;()</code>.</p>
<h1><a name="panics-1" href="#panics-1">Panics</a></h1>
<p>This method will panic if the sum of all values overflows.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><div class="template">template &lt;class U&gt;</div><span class="static">static</span><span class="function-auto">auto</span><a class="function-name" name="method.try_from.unsigned.tryfrom.unsigned" href="sus-num-u8.html#method.try_from.unsigned.tryfrom.unsigned">try_from</a>(U u) -&gt; Result&lt;u8, ::sus::num::TryFromIntError&gt;</div>
          </div>
        </div>
        <div class="description long">
          <p>Tries to construct a u8 from an unsigned integer type (u8, u16, u32,
etc).</p>
<p>Returns an error if the source value is outside of the range of u8.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><div class="template">template &lt;class U&gt;</div><span class="static">static</span><span class="function-auto">auto</span><a class="function-name" name="method.try_from.unsigned.tryfrom.unsignedprimitive" href="sus-num-u8.html#method.try_from.unsigned.tryfrom.unsignedprimitive">try_from</a>(U u) -&gt; Result&lt;u8, ::sus::num::TryFromIntError&gt;</div>
          </div>
        </div>
        <div class="description long">
          <p>Tries to construct a u8 from an unsigned primitive integer type
(unsigned int, unsigned long, etc).</p>
<p>Returns an error if the source value is outside of the range of u8.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><div class="template">template &lt;class S&gt;</div><span class="static">static</span><span class="function-auto">auto</span><a class="function-name" name="method.try_from.unsigned.tryfrom.signed" href="sus-num-u8.html#method.try_from.unsigned.tryfrom.signed">try_from</a>(S s) -&gt; Result&lt;u8, ::sus::num::TryFromIntError&gt;</div>
          </div>
        </div>
        <div class="description long">
          <p>Tries to construct a u8 from a signed integer type (i8, i16, i32,
etc).</p>
<p>Returns an error if the source value is outside of the range of u8.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><div class="template">template &lt;class S&gt;</div><span class="static">static</span><span class="function-auto">auto</span><a class="function-name" name="method.try_from.unsigned.tryfrom.signedprimitive" href="sus-num-u8.html#method.try_from.unsigned.tryfrom.signedprimitive">try_from</a>(S s) -&gt; Result&lt;u8, ::sus::num::TryFromIntError&gt;</div>
          </div>
        </div>
        <div class="description long">
          <p>Tries to construct a u8 from a signed primitive integer type (int,
long, etc).</p>
<p>Returns an error if the source value is outside of the range of u8.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><div class="template">template &lt;class S&gt;</div><span class="static">static</span><span class="function-auto">auto</span><a class="function-name" name="method.try_from.unsigned.tryfrom.signedenum" href="sus-num-u8.html#method.try_from.unsigned.tryfrom.signedenum">try_from</a>(S s) -&gt; Result&lt;u8, ::sus::num::TryFromIntError&gt;</div>
          </div>
        </div>
        <div class="description long">
          <p>Tries to construct a u8 from a signed enum type (or enum class).</p>
<p>Returns an error if the source value is outside of the range of u8.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><div class="template">template &lt;class U&gt;</div><span class="static">static</span><span class="function-auto">auto</span><a class="function-name" name="method.try_from.unsigned.tryfrom.unsignedenum" href="sus-num-u8.html#method.try_from.unsigned.tryfrom.unsignedenum">try_from</a>(U u) -&gt; Result&lt;u8, ::sus::num::TryFromIntError&gt;</div>
          </div>
        </div>
        <div class="description long">
          <p>Tries to construct a u8 from an unsigned enum type (or enum class).</p>
<p>Returns an error if the source value is outside of the range of u8.</p>

        </div>
      </div>
    </div>
    <div class="section methods nonstatic">
      <div class="section-header">
        Methods
      </div>
      <div class="section-items">
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.abs_diff" href="sus-num-u8.html#method.abs_diff">abs_diff</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> r) const& -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Computes the absolute difference between self and other.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.checked_add" href="sus-num-u8.html#method.checked_add">checked_add</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> rhs) const& -&gt; <a class="type-name" title="class ::sus::option::Option&lt;u8&gt;" href="sus-option-Option.html">Option&lt;u8&gt;</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Checked integer addition. Computes self + rhs, returning None if overflow
occurred.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.checked_add_signed" href="sus-num-u8.html#method.checked_add_signed">checked_add_signed</a>(i8 rhs) const& -&gt; <a class="type-name" title="class ::sus::option::Option&lt;u8&gt;" href="sus-option-Option.html">Option&lt;u8&gt;</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Checked integer addition with an unsigned rhs. Computes self + rhs,
returning None if overflow occurred.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.checked_div" href="sus-num-u8.html#method.checked_div">checked_div</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> rhs) const& -&gt; <a class="type-name" title="class ::sus::option::Option&lt;u8&gt;" href="sus-option-Option.html">Option&lt;u8&gt;</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Checked integer division. Computes self / rhs, returning None if <code>rhs == 0</code>.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.checked_div_euclid" href="sus-num-u8.html#method.checked_div_euclid">checked_div_euclid</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> rhs) const& -&gt; <a class="type-name" title="class ::sus::option::Option&lt;u8&gt;" href="sus-option-Option.html">Option&lt;u8&gt;</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Checked Euclidean division. Computes self.div_euclid(rhs), returning
None if rhs == 0.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.checked_log" href="sus-num-u8.html#method.checked_log">checked_log</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> base) const& -&gt; <a class="type-name" title="class ::sus::option::Option&lt;u32&gt;" href="sus-option-Option.html">Option&lt;u32&gt;</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Returns the logarithm of the number with respect to an arbitrary base,
rounded down.</p>
<p>Returns None if the number is zero, or if the base is not at least 2.</p>
<p>This method might not be optimized owing to implementation details;
<code>checked_log2</code> can produce results more efficiently for base 2, and
<code>checked_log10</code> can produce results more efficiently for base 10.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.checked_log10" href="sus-num-u8.html#method.checked_log10">checked_log10</a>() const& -&gt; <a class="type-name" title="class ::sus::option::Option&lt;u32&gt;" href="sus-option-Option.html">Option&lt;u32&gt;</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Returns the base 10 logarithm of the number, rounded down.</p>
<p>Returns None if the number is zero.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.checked_log2" href="sus-num-u8.html#method.checked_log2">checked_log2</a>() const& -&gt; <a class="type-name" title="class ::sus::option::Option&lt;u32&gt;" href="sus-option-Option.html">Option&lt;u32&gt;</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Returns the base 2 logarithm of the number, rounded down.</p>
<p>Returns None if the number is zero.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.checked_mul" href="sus-num-u8.html#method.checked_mul">checked_mul</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> rhs) const& -&gt; <a class="type-name" title="class ::sus::option::Option&lt;u8&gt;" href="sus-option-Option.html">Option&lt;u8&gt;</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Checked integer multiplication. Computes <code>self * rhs</code>, returning None if
overflow occurred.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.checked_neg" href="sus-num-u8.html#method.checked_neg">checked_neg</a>() const& -&gt; <a class="type-name" title="class ::sus::option::Option&lt;u8&gt;" href="sus-option-Option.html">Option&lt;u8&gt;</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Checked negation. Computes -self, returning None unless <code>self == 0</code>.</p>
<p>Note that negating any positive integer will overflow.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.checked_next_power_of_two" href="sus-num-u8.html#method.checked_next_power_of_two">checked_next_power_of_two</a>() const& -&gt; <a class="type-name" title="class ::sus::option::Option&lt;u8&gt;" href="sus-option-Option.html">Option&lt;u8&gt;</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Returns the smallest power of two greater than or equal to n.</p>
<p>If the next power of two is greater than the type's maximum value, None is
returned, otherwise the power of two is wrapped in Some.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.checked_pow" href="sus-num-u8.html#method.checked_pow">checked_pow</a>(<a class="type-name" title="struct u32" href="sus-num-u32.html">u32</a> rhs) const& -&gt; <a class="type-name" title="class ::sus::option::Option&lt;u8&gt;" href="sus-option-Option.html">Option&lt;u8&gt;</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Checked exponentiation. Computes <code>u8::pow(exp)</code>, returning None if
overflow occurred.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.checked_rem" href="sus-num-u8.html#method.checked_rem">checked_rem</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> rhs) const& -&gt; <a class="type-name" title="class ::sus::option::Option&lt;u8&gt;" href="sus-option-Option.html">Option&lt;u8&gt;</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Checked integer remainder. Computes <code>self % rhs</code>, returning None if <code>rhs == 0</code>.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.checked_rem_euclid" href="sus-num-u8.html#method.checked_rem_euclid">checked_rem_euclid</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> rhs) const& -&gt; <a class="type-name" title="class ::sus::option::Option&lt;u8&gt;" href="sus-option-Option.html">Option&lt;u8&gt;</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Checked Euclidean modulo. Computes self.rem_euclid(rhs), returning None if
<code>rhs == 0</code>.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.checked_shl" href="sus-num-u8.html#method.checked_shl">checked_shl</a>(<a class="type-name" title="struct u32" href="sus-num-u32.html">u32</a> rhs) const& -&gt; <a class="type-name" title="class ::sus::option::Option&lt;u8&gt;" href="sus-option-Option.html">Option&lt;u8&gt;</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Checked shift left. Computes <code>*this &lt;&lt; rhs</code>, returning None if rhs is
larger than or equal to the number of bits in self.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.checked_shr" href="sus-num-u8.html#method.checked_shr">checked_shr</a>(<a class="type-name" title="struct u32" href="sus-num-u32.html">u32</a> rhs) const& -&gt; <a class="type-name" title="class ::sus::option::Option&lt;u8&gt;" href="sus-option-Option.html">Option&lt;u8&gt;</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Checked shift right. Computes <code>*this &gt;&gt; rhs</code>, returning None if rhs is
larger than or equal to the number of bits in self.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.checked_sub" href="sus-num-u8.html#method.checked_sub">checked_sub</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> rhs) const& -&gt; <a class="type-name" title="class ::sus::option::Option&lt;u8&gt;" href="sus-option-Option.html">Option&lt;u8&gt;</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Checked integer subtraction. Computes self - rhs, returning None if overflow
occurred.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.count_ones" href="sus-num-u8.html#method.count_ones">count_ones</a>() const& -&gt; <a class="type-name" title="struct u32" href="sus-num-u32.html">u32</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Returns the number of ones in the binary representation of the current
value.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.count_zeros" href="sus-num-u8.html#method.count_zeros">count_zeros</a>() const& -&gt; <a class="type-name" title="struct u32" href="sus-num-u32.html">u32</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Returns the number of zeros in the binary representation of the current
value.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.div_euclid" href="sus-num-u8.html#method.div_euclid">div_euclid</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> rhs) const& -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Performs Euclidean division.</p>
<p>Since, for the positive integers, all common definitions of division are
equal, this is exactly equal to self / rhs.</p>
<h1><a name="panics-2" href="#panics-2">Panics</a></h1>
<p>This function will panic if <code>rhs</code> is 0.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.is_power_of_two" href="sus-num-u8.html#method.is_power_of_two">is_power_of_two</a>() const& -&gt; bool</div>
          </div>
        </div>
        <div class="description long">
          <p>Returns <code>true</code> if and only if <code>self == 2^k</code> for some <code>k</code>.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.leading_ones" href="sus-num-u8.html#method.leading_ones">leading_ones</a>() const& -&gt; <a class="type-name" title="struct u32" href="sus-num-u32.html">u32</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Returns the number of leading ones in the binary representation of the
current value.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.leading_zeros" href="sus-num-u8.html#method.leading_zeros">leading_zeros</a>() const& -&gt; <a class="type-name" title="struct u32" href="sus-num-u32.html">u32</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Returns the number of leading zeros in the binary representation of the
current value.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.log" href="sus-num-u8.html#method.log">log</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> base) const& -&gt; <a class="type-name" title="struct u32" href="sus-num-u32.html">u32</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Returns the logarithm of the number with respect to an arbitrary base,
rounded down.</p>
<p>This method might not be optimized owing to implementation details; log2 can
produce results more efficiently for base 2, and log10 can produce results
more efficiently for base 10.</p>
<h1><a name="panics-3" href="#panics-3">Panics</a></h1>
<p>When the number is zero, or if the base is not at least 2, the function will
panic.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.log10" href="sus-num-u8.html#method.log10">log10</a>() const& -&gt; <a class="type-name" title="struct u32" href="sus-num-u32.html">u32</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Returns the base 10 logarithm of the number, rounded down.</p>
<h1><a name="panics-4" href="#panics-4">Panics</a></h1>
<p>When the number is zero the function will panic.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.log2" href="sus-num-u8.html#method.log2">log2</a>() const& -&gt; <a class="type-name" title="struct u32" href="sus-num-u32.html">u32</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Returns the base 2 logarithm of the number, rounded down.</p>
<h1><a name="panics-5" href="#panics-5">Panics</a></h1>
<p>When the number is zero the function will panic.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.next_power_of_two" href="sus-num-u8.html#method.next_power_of_two">next_power_of_two</a>() const& -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Returns the smallest power of two greater than or equal to self.</p>
<h1><a name="panics-6" href="#panics-6">Panics</a></h1>
<p>The function panics when the return value overflows (i.e.,
<code>self &gt; (1 &lt;&lt; (N-1))</code> for type uN).</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.overflowing_add" href="sus-num-u8.html#method.overflowing_add">overflowing_add</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> rhs) const& -&gt; <a class="type-name" title="class sus::tuple_type::Tuple&lt;u8, _Bool&gt;" href="sus-tuple_type-Tuple.html">Tuple&lt;u8, _Bool&gt;</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Calculates self + rhs</p>
<p>Returns a tuple of the addition along with a boolean indicating whether an
arithmetic overflow would occur. If an overflow would have occurred then the
wrapped value is returned.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.overflowing_add_signed" href="sus-num-u8.html#method.overflowing_add_signed">overflowing_add_signed</a>(i8 rhs) const& -&gt; <a class="type-name" title="class ::sus::tuple_type::Tuple&lt;u8, _Bool&gt;" href="sus-tuple_type-Tuple.html">Tuple&lt;u8, _Bool&gt;</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Calculates self + rhs with an unsigned rhs</p>
<p>Returns a tuple of the addition along with a boolean indicating whether an
arithmetic overflow would occur. If an overflow would have occurred then the
wrapped value is returned.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.overflowing_div" href="sus-num-u8.html#method.overflowing_div">overflowing_div</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> rhs) const& -&gt; <a class="type-name" title="class ::sus::tuple_type::Tuple&lt;u8, _Bool&gt;" href="sus-tuple_type-Tuple.html">Tuple&lt;u8, _Bool&gt;</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Calculates the divisor when self is divided by rhs.</p>
<p>Returns a tuple of the divisor along with a boolean indicating whether an
arithmetic overflow would occur. Note that for unsigned integers overflow
never occurs, so the second value is always false.</p>
<h1><a name="panics-7" href="#panics-7">Panics</a></h1>
<p>This function will panic if <code>rhs</code> is 0.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.overflowing_div_euclid" href="sus-num-u8.html#method.overflowing_div_euclid">overflowing_div_euclid</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> rhs) const& -&gt; <a class="type-name" title="class ::sus::tuple_type::Tuple&lt;u8, _Bool&gt;" href="sus-tuple_type-Tuple.html">Tuple&lt;u8, _Bool&gt;</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Calculates the quotient of Euclidean division self.div_euclid(rhs).</p>
<p>Returns a tuple of the divisor along with a boolean indicating whether an
arithmetic overflow would occur. Note that for unsigned integers overflow
never occurs, so the second value is always false. Since, for the positive
integers, all common definitions of division are equal, this is exactly
equal to self.overflowing_div(rhs).</p>
<h1><a name="panics-8" href="#panics-8">Panics</a></h1>
<p>This function will panic if <code>rhs</code> is 0.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.overflowing_mul" href="sus-num-u8.html#method.overflowing_mul">overflowing_mul</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> rhs) const& -&gt; <a class="type-name" title="class ::sus::tuple_type::Tuple&lt;u8, _Bool&gt;" href="sus-tuple_type-Tuple.html">Tuple&lt;u8, _Bool&gt;</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Calculates the multiplication of self and <code>rhs</code>.</p>
<p>Returns a tuple of the multiplication along with a boolean indicating
whether an arithmetic overflow would occur. If an overflow would have
occurred then the wrapped value is returned.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.overflowing_neg" href="sus-num-u8.html#method.overflowing_neg">overflowing_neg</a>() const& -&gt; <a class="type-name" title="class ::sus::tuple_type::Tuple&lt;u8, _Bool&gt;" href="sus-tuple_type-Tuple.html">Tuple&lt;u8, _Bool&gt;</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Negates self in an overflowing fashion.</p>
<p>Returns <code>~self + 1</code> using wrapping operations to return the value that
represents the negation of this unsigned value. Note that for positive
unsigned values overflow always occurs, but negating 0 does not overflow.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.overflowing_pow" href="sus-num-u8.html#method.overflowing_pow">overflowing_pow</a>(<a class="type-name" title="struct u32" href="sus-num-u32.html">u32</a> exp) const& -&gt; <a class="type-name" title="class ::sus::tuple_type::Tuple&lt;u8, _Bool&gt;" href="sus-tuple_type-Tuple.html">Tuple&lt;u8, _Bool&gt;</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Raises self to the power of <code>exp</code>, using exponentiation by squaring.</p>
<p>Returns a tuple of the exponentiation along with a bool indicating whether
an overflow happened.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.overflowing_rem" href="sus-num-u8.html#method.overflowing_rem">overflowing_rem</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> rhs) const& -&gt; <a class="type-name" title="class ::sus::tuple_type::Tuple&lt;u8, _Bool&gt;" href="sus-tuple_type-Tuple.html">Tuple&lt;u8, _Bool&gt;</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Calculates the remainder when self is divided by rhs.</p>
<p>Returns a tuple of the remainder after dividing along with a boolean
indicating whether an arithmetic overflow would occur. Note that for
unsigned integers overflow never occurs, so the second value is always
false.</p>
<h1><a name="panics-9" href="#panics-9">Panics</a></h1>
<p>This function will panic if <code>rhs</code> is 0.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.overflowing_rem_euclid" href="sus-num-u8.html#method.overflowing_rem_euclid">overflowing_rem_euclid</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> rhs) const& -&gt; <a class="type-name" title="class ::sus::tuple_type::Tuple&lt;u8, _Bool&gt;" href="sus-tuple_type-Tuple.html">Tuple&lt;u8, _Bool&gt;</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Calculates the remainder self.rem_euclid(rhs) as if by Euclidean division.</p>
<p>Returns a tuple of the modulo after dividing along with a boolean indicating
whether an arithmetic overflow would occur. Note that for unsigned integers
overflow never occurs, so the second value is always false. Since, for the
positive integers, all common definitions of division are equal, this
operation is exactly equal to self.overflowing_rem(rhs).</p>
<h1><a name="panics-01" href="#panics-01">Panics</a></h1>
<p>This function will panic if <code>rhs</code> is 0.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.overflowing_shl" href="sus-num-u8.html#method.overflowing_shl">overflowing_shl</a>(<a class="type-name" title="struct u32" href="sus-num-u32.html">u32</a> rhs) const& -&gt; <a class="type-name" title="class ::sus::tuple_type::Tuple&lt;u8, _Bool&gt;" href="sus-tuple_type-Tuple.html">Tuple&lt;u8, _Bool&gt;</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Shifts self left by rhs bits.</p>
<p>Returns a tuple of the shifted version of self along with a boolean
indicating whether the shift value was larger than or equal to the number of
bits. If the shift value is too large, then value is masked (N-1) where N is
the number of bits, and this value is then used to perform the shift.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.overflowing_shr" href="sus-num-u8.html#method.overflowing_shr">overflowing_shr</a>(<a class="type-name" title="struct u32" href="sus-num-u32.html">u32</a> rhs) const& -&gt; <a class="type-name" title="class ::sus::tuple_type::Tuple&lt;u8, _Bool&gt;" href="sus-tuple_type-Tuple.html">Tuple&lt;u8, _Bool&gt;</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Shifts self right by rhs bits.</p>
<p>Returns a tuple of the shifted version of self along with a boolean
indicating whether the shift value was larger than or equal to the number of
bits. If the shift value is too large, then value is masked (N-1) where N is
the number of bits, and this value is then used to perform the shift.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.overflowing_sub" href="sus-num-u8.html#method.overflowing_sub">overflowing_sub</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> rhs) const& -&gt; <a class="type-name" title="class ::sus::tuple_type::Tuple&lt;u8, _Bool&gt;" href="sus-tuple_type-Tuple.html">Tuple&lt;u8, _Bool&gt;</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Calculates <code>self - rhs</code>.</p>
<p>Returns a tuple of the subtraction along with a boolean indicating whether
an arithmetic overflow would occur. If an overflow would have occurred then
the wrapped value is returned.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.pow" href="sus-num-u8.html#method.pow">pow</a>(<a class="type-name" title="struct u32" href="sus-num-u32.html">u32</a> rhs) const& -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Raises self to the power of <code>exp</code>, using exponentiation by squaring.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.rem_euclid" href="sus-num-u8.html#method.rem_euclid">rem_euclid</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> rhs) const& -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Calculates the least remainder of self (mod rhs).</p>
<p>Since, for the positive integers, all common definitions of division are
equal, this is exactly equal to self % rhs.
///</p>
<h1><a name="panics-11" href="#panics-11">Panics</a></h1>
<p>This function will panic if <code>rhs</code> is 0.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.reverse_bits" href="sus-num-u8.html#method.reverse_bits">reverse_bits</a>() const& -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Reverses the order of bits in the integer. The least significant bit becomes
the most significant bit, second least-significant bit becomes second
most-significant bit, etc.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.rotate_left" href="sus-num-u8.html#method.rotate_left">rotate_left</a>(<a class="type-name" title="struct u32" href="sus-num-u32.html">u32</a> n) const& -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Shifts the bits to the left by a specified amount, <code>n</code>, wrapping the
truncated bits to the end of the resulting integer.</p>
<p>Please note this isn't the same operation as the <code>&lt;&lt;</code> shifting operator!</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.rotate_right" href="sus-num-u8.html#method.rotate_right">rotate_right</a>(<a class="type-name" title="struct u32" href="sus-num-u32.html">u32</a> n) const& -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Shifts the bits to the right by a specified amount, n, wrapping the
truncated bits to the beginning of the resulting integer.</p>
<p>Please note this isn't the same operation as the &gt;&gt; shifting operator!</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.saturating_add" href="sus-num-u8.html#method.saturating_add">saturating_add</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> rhs) const& -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Saturating integer addition. Computes self + rhs, saturating at the numeric
bounds instead of overflowing.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.saturating_add_signed" href="sus-num-u8.html#method.saturating_add_signed">saturating_add_signed</a>(i8 rhs) const& -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Saturating integer addition with an unsigned rhs. Computes self + rhs,
saturating at the numeric bounds instead of overflowing.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.saturating_div" href="sus-num-u8.html#method.saturating_div">saturating_div</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> rhs) const& -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Saturating integer division. Computes self / rhs, saturating at the  numeric
bounds instead of overflowing.</p>
<h1><a name="panics-21" href="#panics-21">Panics</a></h1>
<p>This function will panic if <code>rhs</code> is 0.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.saturating_mul" href="sus-num-u8.html#method.saturating_mul">saturating_mul</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> rhs) const& -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Saturating integer multiplication. Computes <code>self * rhs</code>, saturating at the
numeric bounds instead of overflowing.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.saturating_sub" href="sus-num-u8.html#method.saturating_sub">saturating_sub</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> rhs) const& -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Saturating integer subtraction. Computes self - rhs, saturating at the
numeric bounds instead of overflowing.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.swap_bytes" href="sus-num-u8.html#method.swap_bytes">swap_bytes</a>() const& -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Reverses the byte order of the integer.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.to_be" href="sus-num-u8.html#method.to_be">to_be</a>() const& -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Converts self to big endian from the target's endianness.</p>
<p>On big endian this is a no-op. On little endian the bytes are swapped.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.to_be_bytes" href="sus-num-u8.html#method.to_be_bytes">to_be_bytes</a>() const& -&gt; Array&lt;u8, ::sus::mem::size_of&lt;uint8_t&gt;()&gt;</div>
          </div>
        </div>
        <div class="description long">
          <p>Return the memory representation of this integer as a byte array in
big-endian (network) byte order.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.to_le" href="sus-num-u8.html#method.to_le">to_le</a>() const& -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Converts self to little endian from the target's endianness.</p>
<p>On little endian this is a no-op. On big endian the bytes are swapped.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.to_le_bytes" href="sus-num-u8.html#method.to_le_bytes">to_le_bytes</a>() const& -&gt; Array&lt;u8, ::sus::mem::size_of&lt;uint8_t&gt;()&gt;</div>
          </div>
        </div>
        <div class="description long">
          <p>Return the memory representation of this integer as a byte array in
little-endian byte order.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.to_ne_bytes" href="sus-num-u8.html#method.to_ne_bytes">to_ne_bytes</a>() const& -&gt; Array&lt;u8, ::sus::mem::size_of&lt;uint8_t&gt;()&gt;</div>
          </div>
        </div>
        <div class="description long">
          <p>Return the memory representation of this integer as a byte array in native
byte order.</p>
<p>As the target platform's native endianness is used, portable code should use
<code>to_be_bytes()</code> or <code>to_le_bytes()</code>, as appropriate, instead.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.trailing_ones" href="sus-num-u8.html#method.trailing_ones">trailing_ones</a>() const& -&gt; <a class="type-name" title="struct u32" href="sus-num-u32.html">u32</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Returns the number of trailing ones in the binary representation of the
current value.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.trailing_zeros" href="sus-num-u8.html#method.trailing_zeros">trailing_zeros</a>() const& -&gt; <a class="type-name" title="struct u32" href="sus-num-u32.html">u32</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Returns the number of trailing zeros in the binary representation of the
current value.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.unchecked_add" href="sus-num-u8.html#method.unchecked_add">unchecked_add</a>(<a class="type-name" title="struct ::sus::marker::UnsafeFnMarker" href="sus-marker-UnsafeFnMarker.html">UnsafeFnMarker</a>, <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> rhs) const& -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Unchecked integer addition. Computes self + rhs, assuming overflow cannot
occur.</p>
<h1><a name="safety" href="#safety">Safety</a></h1>
<p>This function is allowed to result in undefined behavior when <code>self + rhs &gt; u8::MAX</code> or <code>self + rhs &lt; u8::MIN</code>, i.e. when <code>checked_add()</code>
would return None.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.unchecked_mul" href="sus-num-u8.html#method.unchecked_mul">unchecked_mul</a>(<a class="type-name" title="struct ::sus::marker::UnsafeFnMarker" href="sus-marker-UnsafeFnMarker.html">UnsafeFnMarker</a>, <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> rhs) const& -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Unchecked integer multiplication. Computes <code>self * rhs</code>, assuming overflow
cannot occur.</p>
<h1><a name="safety-1" href="#safety-1">Safety</a></h1>
<p>This function is allowed to result in undefined behavior when <code>self * rhs &gt; u8::MAX</code> or <code>self * rhs &lt; u8::MIN</code>, i.e. when <code>checked_mul()</code>
would return None.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.unchecked_sub" href="sus-num-u8.html#method.unchecked_sub">unchecked_sub</a>(<a class="type-name" title="struct ::sus::marker::UnsafeFnMarker" href="sus-marker-UnsafeFnMarker.html">UnsafeFnMarker</a>, <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> rhs) const& -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Unchecked integer subtraction. Computes self - rhs, assuming overflow cannot
occur.</p>
<h1><a name="safety-2" href="#safety-2">Safety</a></h1>
<p>This function is allowed to result in undefined behavior when `self</p>
<ul>
<li>rhs &gt; u8::MAX<code>or</code>self - rhs &lt; u8::MIN<code>, i.e. when </code>checked_sub()` would return None.</li>
</ul>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.wrapping_add" href="sus-num-u8.html#method.wrapping_add">wrapping_add</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> rhs) const& -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Wrapping (modular) addition. Computes self + rhs, wrapping around at the
boundary of the type.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.wrapping_add_signed" href="sus-num-u8.html#method.wrapping_add_signed">wrapping_add_signed</a>(i8 rhs) const& -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Wrapping (modular) addition with an unsigned rhs. Computes self + rhs,
wrapping around at the boundary of the type.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.wrapping_div" href="sus-num-u8.html#method.wrapping_div">wrapping_div</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> rhs) const& -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Wrapping (modular) division. Computes self / rhs. Wrapped division on
unsigned types is just normal division. There's no way wrapping could ever
happen. This function exists, so that all operations are accounted for in
the wrapping operations.</p>
<h1><a name="panics-31" href="#panics-31">Panics</a></h1>
<p>This function will panic if <code>rhs</code> is 0.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.wrapping_div_euclid" href="sus-num-u8.html#method.wrapping_div_euclid">wrapping_div_euclid</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> rhs) const& -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Wrapping Euclidean division. Computes self.div_euclid(rhs). Wrapped division
on unsigned types is just normal division.</p>
<p>There's no way wrapping could ever happen. This function exists so that all
operations are accounted for in the wrapping operations. Since, for the
positive integers, all common definitions of division are equal, this is
exactly equal to self.wrapping_div(rhs).</p>
<h1><a name="panics-41" href="#panics-41">Panics</a></h1>
<p>This function will panic if <code>rhs</code> is 0.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.wrapping_mul" href="sus-num-u8.html#method.wrapping_mul">wrapping_mul</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> rhs) const& -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Wrapping (modular) multiplication. Computes self * rhs, wrapping around
at the boundary of the type.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.wrapping_neg" href="sus-num-u8.html#method.wrapping_neg">wrapping_neg</a>() const& -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Wrapping (modular) negation. Computes <code>-self</code>, wrapping around at the
boundary of the type.</p>
<p>Since unsigned types do not have negative equivalents all applications
of this function will wrap (except for -0). For values smaller than the
corresponding signed type's maximum the result is the same as casting
the corresponding signed value. Any larger values are equivalent to
<code>MAX + 1 - (val - MAX - 1)</code> where MAX is the corresponding signed type's
maximum.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.wrapping_next_power_of_two" href="sus-num-u8.html#method.wrapping_next_power_of_two">wrapping_next_power_of_two</a>() const& -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Returns the smallest power of two greater than or equal to n.</p>
<p>If the next power of two is greater than the type's maximum value, the
return value is wrapped to 0.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.wrapping_pow" href="sus-num-u8.html#method.wrapping_pow">wrapping_pow</a>(<a class="type-name" title="struct u32" href="sus-num-u32.html">u32</a> exp) const& -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Wrapping (modular) exponentiation. Computes self.pow(exp), wrapping around
at the boundary of the type.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.wrapping_rem" href="sus-num-u8.html#method.wrapping_rem">wrapping_rem</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> rhs) const& -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Wrapping (modular) remainder. Computes self % rhs. Wrapped remainder
calculation on unsigned types is just the regular remainder calculation.</p>
<p>There's no way wrapping could ever happen. This function exists, so that
all operations are accounted for in the wrapping operations.</p>
<h1><a name="panics-51" href="#panics-51">Panics</a></h1>
<p>This function will panic if <code>rhs</code> is 0.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.wrapping_rem_euclid" href="sus-num-u8.html#method.wrapping_rem_euclid">wrapping_rem_euclid</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> rhs) const& -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Wrapping Euclidean modulo. Computes self.rem_euclid(rhs). Wrapped modulo
calculation on unsigned types is just the regular remainder calculation.</p>
<p>Theres no way wrapping could ever happen. This function exists, so that all
operations are accounted for in the wrapping operations. Since, for the
positive integers, all common definitions of division are equal, this is
exactly equal to self.wrapping_rem(rhs).
///</p>
<h1><a name="panics-61" href="#panics-61">Panics</a></h1>
<p>This function will panic if <code>rhs</code> is 0.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.wrapping_shl" href="sus-num-u8.html#method.wrapping_shl">wrapping_shl</a>(<a class="type-name" title="struct u32" href="sus-num-u32.html">u32</a> rhs) const& -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Panic-free bitwise shift-left; yields <code>*this &lt;&lt; mask(rhs)</code>, where mask
removes any high-order bits of <code>rhs</code> that would cause the shift to exceed
the bitwidth of the type.</p>
<p>Note that this is not the same as a rotate-left; the RHS of a wrapping
shift-left is restricted to the range of the type, rather than the bits
shifted out of the LHS being returned to the other end. The primitive
integer types all implement a rotate_left function, which may be what you
want instead.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.wrapping_shr" href="sus-num-u8.html#method.wrapping_shr">wrapping_shr</a>(<a class="type-name" title="struct u32" href="sus-num-u32.html">u32</a> rhs) const& -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Panic-free bitwise shift-right; yields <code>*this &gt;&gt; mask(rhs)</code>, where mask
removes any high-order bits of <code>rhs</code> that would cause the shift to exceed
the bitwidth of the type.</p>
<p>Note that this is not the same as a rotate-right; the RHS of a wrapping
shift-right is restricted to the range of the type, rather than the bits
shifted out of the LHS being returned to the other end. The primitive
integer types all implement a rotate_right function, which may be what you
want instead.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.wrapping_sub" href="sus-num-u8.html#method.wrapping_sub">wrapping_sub</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> rhs) const& -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Wrapping (modular) subtraction. Computes self - rhs, wrapping around at the
boundary of the type.</p>

        </div>
      </div>
    </div>
    <div class="section methods conversion">
      <div class="section-header">
        Conversions
      </div>
      <div class="section-items">
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><div class="template">template &lt;class U&gt;</div><a class="function-name" name="method.operator U" href="sus-num-u8.html#method.operator U">operator U</a>() const</div>
          </div>
        </div>
        <div class="description long">
          <p>Conversion from the numeric type to a C++ primitive type.</p>
<p>This converts to unsigned primitives which are at least as large as the
<a href="sus-num-u8.html"><code>u8</code></a>.</p>
<pre><code>auto d = uint32_t{3_u32};  // Compiles.
auto e = uint32_t(3_u32);  // Compiles.
uint32_t f = 3_u32;  // Compiles.

auto d = uint16_t{3_u32};  // Does not compile.
auto e = uint16_t(3_u32);  // Does not compile.
uint16_t f = 3_u32;  // Does not compile.
</code></pre>
<p>Potentially-lossy type conversions can be forced through the
<a href="sus-construct-Transmogrify.html"><code>Transmogrify</code></a> concept, such as
<code>sus::mog&lt;uint16_t&gt;(3_u32)</code> or <code>sus::mog&lt;int32_t&gt;(3_u32)</code>, or even
<code>sus::mog&lt;i32&gt;(3_u32)</code>.</p>

        </div>
      </div>
    </div>
    <div class="section methods nonstatic">
      <div class="section-header">
        Operators
      </div>
      <div class="section-items">
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.operator%=" href="sus-num-u8.html#method.operator%=">operator%=</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> r) & -&gt; void</div>
          </div>
        </div>
        <div class="description long">
          <p>Satisfies the <a href="sus-num-RemAssign.html"><code>RemAssign&lt;u8&gt;</code></a> concept.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.operator&=" href="sus-num-u8.html#method.operator&=">operator&=</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> r) & -&gt; void</div>
          </div>
        </div>
        <div class="description long">
          <p>Satisfies the <a href="sus-num-BitAndAssign.html"><code>BitAndAssign&lt;u8&gt;</code></a>
concept.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.operator*=" href="sus-num-u8.html#method.operator*=">operator*=</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> r) & -&gt; void</div>
          </div>
        </div>
        <div class="description long">
          <p>Satisfies the <a href="sus-num-MulAssign.html"><code>MulAssign&lt;u8&gt;</code></a> concept.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.operator+=" href="sus-num-u8.html#method.operator+=">operator+=</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> r) & -&gt; void</div>
          </div>
        </div>
        <div class="description long">
          <p>Satisfies the <a href="sus-num-AddAssign.html"><code>AddAssign&lt;u8&gt;</code></a> concept.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.operator-=" href="sus-num-u8.html#method.operator-=">operator-=</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> r) & -&gt; void</div>
          </div>
        </div>
        <div class="description long">
          <p>Satisfies the <a href="sus-num-SubAssign.html"><code>SubAssign&lt;u8&gt;</code></a> concept.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.operator/=" href="sus-num-u8.html#method.operator/=">operator/=</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> r) & -&gt; void</div>
          </div>
        </div>
        <div class="description long">
          <p>Satisfies the <a href="sus-num-DivAssign.html"><code>DivAssign&lt;u8&gt;</code></a> concept.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.operator&lt;&lt;=" href="sus-num-u8.html#method.operator&lt;&lt;=">operator&lt;&lt;=</a>(<a class="type-name" title="struct u32" href="sus-num-u32.html">u32</a> r) & -&gt; void</div>
          </div>
        </div>
        <div class="description long">
          <p>Satisfies the <a href="sus-num-ShlAssign.html"><code>ShlAssign&lt;u8&gt;</code></a> concept.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><div class="template">template &lt;class U&gt;</div><span class="function-auto">auto</span><a class="function-name" name="method.operator=.assign.unsigned.small.typed" href="sus-num-u8.html#method.operator=.assign.unsigned.small.typed">operator=</a>(U v) -&gt; <a class="type-name" title="u8 &" href="sus-num-u8.html">u8 &</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Assignment from unsigned types (u8, u16, etc.) where no bits are lost.</p>
<p>For conversions from types with a larger range use
<a href="#method.try_from"><code>try_from</code></a>. For lossy conversions use the
<a href="sus-construct-Transmogrify.html"><code>Transmogrify</code></a> concept with
<a href="sus-construct-fn.mog.html"><code>sus::mog&lt;u8&gt;()</code></a>.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><div class="template">template &lt;class P&gt;</div><span class="function-auto">auto</span><a class="function-name" name="method.operator=.assign.unsigned.small.primitive" href="sus-num-u8.html#method.operator=.assign.unsigned.small.primitive">operator=</a>(P v) -&gt; <a class="type-name" title="u8 &" href="sus-num-u8.html">u8 &</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Assignment from unsigned primitive types (unsigned int, unsigned long, etc.)
where no bits are lost.</p>
<p>For conversions from types with a larger range use
<a href="#method.try_from"><code>try_from</code></a>. For lossy conversions use the
<a href="sus-construct-Transmogrify.html"><code>Transmogrify</code></a> concept with
<a href="sus-construct-fn.mog.html"><code>sus::mog&lt;u8&gt;()</code></a>.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><div class="template">template &lt;class P&gt;</div><span class="function-auto">auto</span><a class="function-name" name="method.operator=.assign.unsigned.smallenum" href="sus-num-u8.html#method.operator=.assign.unsigned.smallenum">operator=</a>(P v) -&gt; <a class="type-name" title="u8 &" href="sus-num-u8.html">u8 &</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Assignment from unsigned enum types where no bits are lost.</p>
<p>For conversions from types with a larger range use
<a href="#method.try_from"><code>try_from</code></a>. For lossy conversions use the
<a href="sus-construct-Transmogrify.html"><code>Transmogrify</code></a> concept with
<a href="sus-construct-fn.mog.html"><code>sus::mog&lt;u8&gt;()</code></a>.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.operator&gt;&gt;=" href="sus-num-u8.html#method.operator&gt;&gt;=">operator&gt;&gt;=</a>(<a class="type-name" title="struct u32" href="sus-num-u32.html">u32</a> r) & -&gt; void</div>
          </div>
        </div>
        <div class="description long">
          <p>Satisfies the <a href="sus-num-ShrAssign.html"><code>ShrAssign&lt;u8&gt;</code></a> concept.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.operator^=" href="sus-num-u8.html#method.operator^=">operator^=</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> r) & -&gt; void</div>
          </div>
        </div>
        <div class="description long">
          <p>Satisfies the <a href="sus-num-BitXorAssign.html"><code>BitXorAssign&lt;u8&gt;</code></a>
concept.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.operator|=" href="sus-num-u8.html#method.operator|=">operator|=</a>(<a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a> r) & -&gt; void</div>
          </div>
        </div>
        <div class="description long">
          <p>Satisfies the <a href="sus-num-BitOrAssign.html"><code>BitOrAssign&lt;u8&gt;</code></a> concept.</p>

        </div>
        <div class="overload-set item-name">
          <div class="overload">
            <div class="function-signature"><span class="function-auto">auto</span><a class="function-name" name="method.operator~" href="sus-num-u8.html#method.operator~">operator~</a>() const& -&gt; <a class="type-name" title="struct u8" href="sus-num-u8.html">u8</a></div>
          </div>
        </div>
        <div class="description long">
          <p>Satisfies the <a href="sus-num-BitNot.html"><code>BitNot&lt;u8&gt;</code></a> concept.</p>

        </div>
      </div>
    </div>
    <div class="section fields nonstatic">
      <div class="section-header">
        Data Members
      </div>
      <div class="section-items">
        <div class="section-item">
          <div class="item-name member-signature">
            uint8_t
            <a class="field-name" name="field.primitive_value" href="#field.primitive_value">primitive_value</a>
          </div>
          <div class="description long">
            <p>The inner primitive value. Prefer to cast to the desired primitive type,
such as with <code>uint32_t{n}</code> for a numeric value <code>n</code>.</p>

          </div>
        </div>
      </div>
    </div>
  </div>
</body>
