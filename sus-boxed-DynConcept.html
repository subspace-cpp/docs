<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type"></meta>
    <meta name="generator" content="subdoc"></meta>
    <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
    <meta property="og:type" content="website"></meta>
    <meta property="og:site_name" content="Subspace"></meta>
    <title>sus::boxed::DynConcept - Subspace</title>
    <meta property="og:title" content="sus::boxed::DynConcept - Subspace"></meta>
    <meta name="description" content="A concept for generalized type erasure of concepts, allowing use of a concept-satisfying type T without knowing the concrete type T."></meta>
    <meta property="og:description" content="A concept for generalized type erasure of concepts, allowing use of a concept-satisfying type T without knowing the concrete type T."></meta>
    <script src="https://unpkg.com/lunr/lunr.js"></script>
    <script src="./search_db.js"></script>
    <script>
      
        // Delayed loading of whatever was in the search box.
        var searchDelayLoad;

        // The search box's dynamic behaviour.
        document.addEventListener("keyup", e => {
          if (e.key === 's') {
            document.querySelector('.search-input').focus();
          }
          if (e.key === 'Escape') {
            document.querySelector('.search-input').blur();
            navigateToSearch(null);
            e.preventDefault();
          }
        });
        function navigateToSearch(query) {
          window.clearTimeout(searchDelayLoad);
          searchDelayLoad = null;

          let without_search =
              window.location.origin + window.location.pathname;
          if (query) {
            window.history.replaceState(null, "",
              without_search + "?" + `search=${query}`);
          } else {
            window.history.replaceState(null, "", without_search);
          }
          maybeShowSearchResults();
        }
        addEventListener("load", event => {
          document.querySelector(".search-input").oninput = (e) => {
            window.clearTimeout(searchDelayLoad);
            searchDelayLoad = window.setTimeout(() => {
              navigateToSearch(e.target.value);
            }, 1000);
          };
          document.querySelector(".search-input").onkeypress = (e) => {
            if (e.key == "Enter") {
              navigateToSearch(e.target.value);
              e.preventDefault();
            }
          };
          var searchPlaceholder;
          document.querySelector(".search-input").onfocus = (e) => {
            searchPlaceholder = e.target.placeholder;
            e.target.placeholder = "Type your search here.";
            navigateToSearch(e.target.value);
          };
          document.querySelector(".search-input").onblur = (e) => {
            e.target.placeholder = searchPlaceholder;
            searchPlaceholder = null;
          };
        });

        // Show or hide any DOM element.
        function showHide(selector, show) {
          if (show)
            document.querySelector(selector).classList.remove("hidden");
          else
            document.querySelector(selector).classList.add("hidden");
        }

        function searchQuery() {
          const params = new Proxy(
            new URLSearchParams(window.location.search), {
              get: (searchParams, prop) => searchParams.get(prop),
            }
          );
          return params.search;
        }

        // Showing search results.
        async function populateSearchResults(loaded) {
          const search_db = loaded.search_db;
          const idx = loaded.idx;

          // lunrjs treats `:` specially and `::` breaks the query syntax, so
          // just split into two words.
          const query = searchQuery().split("::").join(" ");
          let content = '';
          try {
            const results = idx.search(query);
            for (r of results) {
              const item = search_db[r.ref];

              const type = item.type;
              const url = item.url;
              const name = item.name;
              const full_name = item.full_name;
              const summmary = item.summary ? item.summary : "";

              content += `\
                <a class="search-results-link" href="${url}">
                  <span class="search-results-type"><span>${type}</span></span>\
                  <span class="search-results-name"><span>${full_name}</span></span>\
                  <span class="search-results-summary"><span>${summmary}</span></span>\
                </a>\
                `
            }
          } catch (err) {
            content +=
                `<div class="search-error">Search error: ${err.message}</div>`;
          }

          let content_elem = document.querySelector(".search-results-content");
          content_elem.innerHTML = content;

          let header_elem = document.querySelector(".search-results-header");
          header_elem.innerText = "Search results";
        }

        var cache_idx;

        // Searching via https://lunrjs.com.
        //
        // Load the JSON search database, which will be turned into a search
        // index. Returns an object with two fields:
        // - search_db: the contents of the search.json file.
        // - idx: the lunr search index.
        //   Documented at https://lunrjs.com/docs/lunr.Index.html.
        async function loadSearchIndex() {
          // This is not widely supported yet (not on Safari), so instead we
          // turned the json file into a js file that sets a global variable. :|
          //async function load_search_db() {
          //  let x = await import('./search.json', {
          //    with: {type: 'json'}
          //  });
          //  return x.default;
          //}

          async function load_idx(search_db) {
            let idx = lunr(function () {
              this.ref('index');
              this.field('name', {
                'boost': 2
              });
              this.field('full_name', {
                'boost': 2
              });
              this.field('split_name', {
                'boost': 0.5
              });
              this.field('summary', {
                'boost': 1
              });
              this.field('full_description', {
                'boost': 0.75
              });

              // No stemming?
              // this.pipeline = new lunr.Pipeline();

              this.use(builder => {
                function splitColons(token) {
                  return token.toString().split("::").map(str => {
                    return token.clone().update(() => { return str })
                  })
                }
                lunr.Pipeline.registerFunction(splitColons, 'splitColons')
                builder.searchPipeline.before(lunr.stemmer, splitColons)
              });

              search_db.forEach(item => {
                this.add(item, {
                  'boost': item.weight ? Number(item.weight) : 1
                })
              }, this);
            });
            let out = {};
            out.search_db = search_db;
            out.idx = idx;
            return out;
          };

          if (!cache_idx) {
            cache_idx = await load_idx(g_search_db);
          }
          return cache_idx;
        }

        // If there's a search query, hide the other content and asynchronously
        // show the search results. Otherwise, hide search content and show the
        // rest immediately.
        function maybeShowSearchResults() {
          const query = searchQuery();
          if (query) {
            showHide(".main-content", false);

            let input = document.querySelector(".search-input");
            input.value = query;

            let header_elem = document.querySelector(".search-results-header");
            header_elem.innerText = "Loading search results...";

            let content_ele = document.querySelector(".search-results-content");
            content_ele.innerText = "";

            loadSearchIndex().then(populateSearchResults)
          } else {
            showHide(".main-content", true);

            let header_elem = document.querySelector(".search-results-header");
            header_elem.innerText = "";

            let content_ele = document.querySelector(".search-results-content");
            content_ele.innerText = "";
          }
        }

        
    </script>
    <link rel="stylesheet" href="subdoc-test-style.css">
    <link rel="icon" type="image/png" href="logo.png">
    <link rel="alternate icon" type="image/png" href="logo32.png">
    <link rel="alternate icon" type="image/png" href="logo16.png">
    <meta property="og:image" content="logo.png"></meta>
  </head>

  <body>
    <nav class="topbar">
      <button class="sidebar-menu-button" onclick="let e = document.getElementsByClassName('sidebar')[0];e.classList.toggle('shown');">
        â˜°
      </button>
      <a class="topbar-logo-link" href="index.html"><div class="topbar-logo-border">
          <img class="topbar-logo" src="logo.png"></img>
        </div></a>
      <span class="topbar-text-area">
        <span class="topbar-title">
          <a href="#">DynConcept</a>
        </span>
      </span>
    </nav>
    <nav class="sidebar">
      <a class="sidebar-logo-link" href="index.html"><div class="sidebar-logo-border">
          <img class="sidebar-logo" src="logo.png"></img>
        </div></a>
      <div class="sidebar-pretitle sidebar-text">
        concept
      </div>
      <div class="sidebar-title sidebar-text">
        <a href="#">DynConcept</a>
      </div>
      <div class="sidebar-subtitle sidebar-text">
      </div>
      <div class="sidebar-links sidebar-text">
        <ul>
        </ul>
      </div>
    </nav>
    <main>
      <nav class="search-nav">
        <form class="search-form">
          <input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press 'S' to search...">
          </input>
        </form>
      </nav>
      <section class="search-results">
        <h1 class="search-results-header">
        </h1>
        <div class="search-results-content">
        </div>
      </section>
      <section class="main-content">
        <script>maybeShowSearchResults()</script>
        <div class="concept">
          <div class="section overview">
            <h1 class="section-header">
              <span>
                Concept
              </span>
              <a class="project-name" href="index.html">Subspace</a>
              <span class="namespace-dots">::</span>
              <a class="namespace-name" href="namespace.sus.html">sus</a>
              <span class="namespace-dots">::</span>
              <a class="namespace-name" href="sus-namespace.boxed.html">boxed</a>
              <span class="namespace-dots">::</span>
              <a class="concept-name" href="#">DynConcept</a>
            </h1>
            <div class="type-signature"><div class="src rightside"><a href="https://github.com/chromium/subspace/blob/main/sus/boxed/dyn.h#L288">source</a></div><pre class="template">template &lt;class DynC, class ConcreteT&gt;</pre><span class="concept">
                concept
              </span><span class="type-name">
                DynConcept
              </span><div>
                <div class="requires">
                  <span class="requires-keyword keyword">
                    requires
                  </span>
                  <div class="requires-constraint"><pre class="requires-constraint-line">requires {</pre><pre class="requires-constraint-line">  // The types are not qualified or references.</pre><pre class="requires-constraint-line">  requires std::same_as&lt;DynC, std::remove_cvref_t&lt;DynC&gt;&gt;;</pre><pre class="requires-constraint-line">  requires std::same_as&lt;ConcreteT, std::remove_cvref_t&lt;ConcreteT&gt;&gt;;</pre><pre class="requires-constraint-line"></pre><pre class="requires-constraint-line">  // The SatisfiesConcept bool tests against the concept.</pre><pre class="requires-constraint-line">  { DynC::template SatisfiesConcept&lt;ConcreteT&gt; } -&gt; std::same_as&lt;const bool&&gt;;</pre><pre class="requires-constraint-line">  // The `DynTyped` type alias names the typed subclass. The `DynTyped` class</pre><pre class="requires-constraint-line">  // has two template parameters, the concrete type and the storage type (value</pre><pre class="requires-constraint-line">  // or reference).</pre><pre class="requires-constraint-line">  typename DynC::template DynTyped&lt;ConcreteT, ConcreteT&gt;;</pre><pre class="requires-constraint-line"></pre><pre class="requires-constraint-line">  // The type-erased `DynC` must also satisfy the concept, so it can be used</pre><pre class="requires-constraint-line">  // in templated code still as well.</pre><pre class="requires-constraint-line">  requires DynC::template SatisfiesConcept&lt;DynC&gt;;</pre><pre class="requires-constraint-line"></pre><pre class="requires-constraint-line">  // The typed class is a subclass of the type-erased `DynC` base class, and is</pre><pre class="requires-constraint-line">  // final.</pre><pre class="requires-constraint-line">  requires std::is_base_of_v&lt;</pre><pre class="requires-constraint-line">      DynC, typename DynC::template DynTyped&lt;ConcreteT, ConcreteT&gt;&gt;;</pre><pre class="requires-constraint-line">  requires std::is_final_v&lt;</pre><pre class="requires-constraint-line">      typename DynC::template DynTyped&lt;ConcreteT, ConcreteT&gt;&gt;;</pre><pre class="requires-constraint-line"></pre><pre class="requires-constraint-line">  // The type-erased `DynC` can not be moved (which would slice the typed</pre><pre class="requires-constraint-line">  // subclass off).</pre><pre class="requires-constraint-line">  requires !std::is_move_constructible_v&lt;DynC&gt;;</pre><pre class="requires-constraint-line">  requires !std::is_move_assignable_v&lt;DynC&gt;;</pre><pre class="requires-constraint-line">}</pre></div>
                </div>
              </div></div>
            <div class="description long">
              <p>A concept for generalized type erasure of concepts, allowing use of a
concept-satisfying type <code>T</code> without knowing the concrete type <code>T</code>.</p>
<p>By providing a virtual type-erasure class that satisifies
<a href="sus-boxed-DynConcept.html"><code>DynConcept</code></a> along
with a concept <code>C</code>, it allows the use of generic concept-satisfying objects
without the use of templates.
This means a function accepting a concept-satisying object as
a parameter can:</p>
<ul>
<li>Be written outside of the header.</li>
<li>Be a virtual method.</li>
<li>Be part of a non-header-only library API.</li>
</ul>
<p>We can not specify a concept as a type parameter so there is a level of
indirection involved and the concept itself is not named.</p>
<p>To type-erase a concept <code>C</code>, there must be a virtual class <code>DynC</code> declared
that satisfies this <a href="sus-boxed-DynConcept.html"><code>DynConcept</code></a> concept
for all concrete types <code>ConcreteT</code>
which satisfy the concept <code>C</code> being type-erased.</p>
<h1><a name="performing-the-type-erasure" href="#performing-the-type-erasure">Performing the type erasure</a></h1>
<p>To type-erase a concept-satisfying object (a &quot;concept object&quot;)
into the heap, use <a href="sus-boxed-Box.html"><code>Box</code></a>.
For example <code>Box&lt;DynC&gt;</code> would hold a type-erased
heap-allocated object that is known to satisfy the concept <code>C</code>. A
<a href="sus-boxed-Box.html"><code>Box</code></a> should
always be used when storing the function object beyond the current
stack frame, such as in a class data member. It can also be done
for ease of working with type-erased concepts.</p>
<pre><code><span class="comment">// This function receives and uses a type-erased concept object.</span>
<span class="keyword">void</span> use_fn<span class="punct">(</span>sus::Box<span class="punct">&lt;</span>sus::fn::DynFn<span class="punct">&lt;</span><span class="keyword">void</span><span class="punct">(</span>i32<span class="punct">)</span><span class="punct">&gt;</span><span class="punct">&gt;</span> b<span class="punct">)</span> <span class="punct">{</span> b<span class="punct">(</span>2<span class="punct">)</span><span class="punct">;</span> <span class="punct">}</span>
</code></pre>
<p>A <a href="sus-boxed-Box.html"><code>Box</code></a> holding a type-erased concept can be
constructed with the
<a href="sus-boxed-Box.html#method.from.dync"><code>from</code></a> constructor method. It receives a
concept object as an input, and moves it to the heap.
Since this satisfies the <a href="sus-construct-From.html"><code>From</code></a> concept, the
<code>Box&lt;DynC&gt;</code> can also be constructed with type deduction through
<a href="sus-construct-fn.into.html"><code>sus::into()</code></a>.</p>
<pre><code><span class="keyword">auto</span> f <span class="punct">=</span> <span class="punct">[</span><span class="punct">]</span><span class="punct">(</span>i32 i<span class="punct">)</span> <span class="punct">{</span> fmt::println<span class="punct">(</span><span class="string">&quot;{}&quot;</span><span class="punct">,</span> i<span class="punct">)</span><span class="punct">;</span> <span class="punct">}</span><span class="punct">;</span>
<span class="comment">// Converts the lambda, which satisfies the `Fn&lt;void(i32)&gt;` concept</span>
<span class="comment">// into a `Box&lt;DynFn&lt;void(i32)&gt;&gt;` for the function argument.</span>
use_fn<span class="punct">(</span>sus::into<span class="punct">(</span>f<span class="punct">)</span><span class="punct">)</span><span class="punct">;</span>
</code></pre>
<p>In performance-sensitive code, it can be necessary to avoid heap
allocations while working with type-erased concept objects, or to work with
a concept object without taking ownership of it. It is possible
to receive a type-erased concept object by reference instead of through a
<a href="sus-boxed-Box.html"><code>Box</code></a>.</p>
<pre><code><span class="comment">// This function receives and uses a type-erased concept object.</span>
<span class="keyword">void</span> use_fn_ref<span class="punct">(</span><span class="keyword">const</span> sus::fn::DynFn<span class="punct">&lt;</span><span class="keyword">void</span><span class="punct">(</span>i32<span class="punct">)</span><span class="punct">&gt;</span><span class="punct">&amp;</span> b<span class="punct">)</span> <span class="punct">{</span> b<span class="punct">(</span>2<span class="punct">)</span><span class="punct">;</span> <span class="punct">}</span>
</code></pre>
<p>To get a type-erased reference from a concept object, pass it to
<a href="sus-boxed-fn.dyn.html"><code>sus::dyn()</code></a>. The <a href="sus-boxed-fn.dyn.html"><code>sus::dyn()</code></a>
function constructs a type-erasure on the stack and automatically converts
to a reference to it.</p>
<pre><code><span class="keyword">auto</span> f <span class="punct">=</span> <span class="punct">[</span><span class="punct">]</span><span class="punct">(</span>i32 i<span class="punct">)</span> <span class="punct">{</span> fmt::println<span class="punct">(</span><span class="string">&quot;{}&quot;</span><span class="punct">,</span> i<span class="punct">)</span><span class="punct">;</span> <span class="punct">}</span><span class="punct">;</span>
<span class="comment">// Erases the type of the lambda, constructing a type-erased reference to a</span>
<span class="comment">// `DynFn` to pass as the function argument.</span>
use_fn_ref<span class="punct">(</span>sus::dyn<span class="punct">&lt;</span>sus::fn::DynFn<span class="punct">&lt;</span><span class="keyword">void</span><span class="punct">(</span>i32<span class="punct">)</span><span class="punct">&gt;</span><span class="punct">&gt;</span><span class="punct">(</span>f<span class="punct">)</span><span class="punct">)</span><span class="punct">;</span>
</code></pre>
<h1><a name="type-erasure-of-concepts-in-the-subspace-library" href="#type-erasure-of-concepts-in-the-subspace-library">Type erasure of concepts in the Subspace library</a></h1>
<p>Some concepts in the Subspace library come with a virtual type-erasure class
that satisfies <a href="sus-boxed-DynConcept.html"><code>DynConcept</code></a> and can be
type-erased into <code>Box&lt;DynC&gt;</code> for the concept <code>C</code>:</p>
<ul>
<li><a href="sus-error-Error.html"><code>Error</code></a></li>
<li><a href="sus-fn-Fn.html"><code>Fn</code></a></li>
<li><a href="sus-fn-FnMut.html"><code>FnMut</code></a></li>
<li><a href="sus-fn-FnOnce.html"><code>FnOnce</code></a></li>
</ul>
<p>For some concepts in the Subspace library, <code>Box&lt;DynC&gt;</code> will also satisfy the
concept <code>C</code> itself, without having use the inner type. See
<a href="sus-boxed-Box.html#box-implements-some-concepts-for-its-inner-type">Box implements some concepts for its inner type</a>.</p>
<p>Since the actual type is erased, it can not be moved or copied. While it can
be constructed on the stack or the heap, any access to it other than its
initial declaration must be through a pointer or reference, similar to
<a href="https://doc.rust-lang.org/std/pin/struct.Pin.html"><code>Pin&lt;T&gt;</code></a> types in
Rust.</p>
<h1><a name="examples" href="#examples">Examples</a></h1>
<h2><a name="implementing-concept-type-erasure" href="#implementing-concept-type-erasure">Implementing concept type-erasure</a></h2>
<p>Providing the mechanism to type erase objects that satisfy a concept named
<code>MyConcept</code> through a <code>DynMyConcept</code> class:</p>
<pre><code><span class="comment">// A concept which requires a single const-access method named `concept_fn`.</span>
<span class="keyword">template</span> <span class="punct">&lt;</span><span class="keyword">class</span> T<span class="punct">&gt;</span>
<span class="keyword">concept</span> MyConcept <span class="punct">=</span> <span class="keyword">requires</span><span class="punct">(</span><span class="keyword">const</span> T<span class="punct">&amp;</span> t<span class="punct">)</span> <span class="punct">{</span>
  <span class="punct">{</span> t<span class="punct">.</span>concept_fn<span class="punct">(</span><span class="punct">)</span> <span class="punct">}</span> <span class="punct">-</span><span class="punct">&gt;</span> std::same_as<span class="punct">&lt;</span><span class="keyword">void</span><span class="punct">&gt;</span><span class="punct">;</span>
<span class="punct">}</span><span class="punct">;</span>

<span class="keyword">template</span> <span class="punct">&lt;</span><span class="keyword">class</span> T<span class="punct">,</span> <span class="keyword">class</span> Store<span class="punct">&gt;</span>
<span class="keyword">class</span> DynMyConceptTyped<span class="punct">;</span>

<span class="keyword">class</span> DynMyConcept <span class="punct">{</span>
  sus_dyn_concept<span class="punct">(</span>MyConcept<span class="punct">,</span> DynMyConcept<span class="punct">,</span> DynMyConceptTyped<span class="punct">)</span><span class="punct">;</span>

 <span class="keyword">public</span>:
  <span class="comment">// Pure virtual concept API.</span>
  <span class="keyword">virtual</span> <span class="keyword">void</span> concept_fn<span class="punct">(</span><span class="punct">)</span> <span class="keyword">const</span> <span class="punct">=</span> 0<span class="punct">;</span>
<span class="punct">}</span><span class="punct">;</span>
<span class="comment">// Verifies that DynMyConcept also satisfies MyConcept, which is required.</span>
<span class="keyword">static_assert</span><span class="punct">(</span>MyConcept<span class="punct">&lt;</span>DynMyConcept<span class="punct">&gt;</span><span class="punct">)</span><span class="punct">;</span>

<span class="keyword">template</span> <span class="punct">&lt;</span><span class="keyword">class</span> T<span class="punct">,</span> <span class="keyword">class</span> Store<span class="punct">&gt;</span>
<span class="keyword">class</span> DynMyConceptTyped final : <span class="keyword">public</span> DynMyConcept <span class="punct">{</span>
  sus_dyn_concept_typed<span class="punct">(</span>MyConcept<span class="punct">,</span> DynMyConcept<span class="punct">,</span> DynMyConceptTyped<span class="punct">,</span> v<span class="punct">)</span><span class="punct">;</span>

  <span class="comment">// Virtual concept API implementation.</span>
  <span class="keyword">void</span> concept_fn<span class="punct">(</span><span class="punct">)</span> <span class="keyword">const</span> override <span class="punct">{</span> <span class="keyword">return</span> v<span class="punct">.</span>concept_fn<span class="punct">(</span><span class="punct">)</span><span class="punct">;</span> <span class="punct">}</span><span class="punct">;</span>
<span class="punct">}</span><span class="punct">;</span>

<span class="comment">// A type which satiesfies `MyConcept`.</span>
<span class="keyword">struct</span> MyConceptType <span class="punct">{</span>
  <span class="keyword">void</span> concept_fn<span class="punct">(</span><span class="punct">)</span> <span class="keyword">const</span> <span class="punct">{</span><span class="punct">}</span>
<span class="punct">}</span><span class="punct">;</span>

<span class="keyword">int</span> main<span class="punct">(</span><span class="punct">)</span> <span class="punct">{</span>
  <span class="comment">// Verifies that DynMyConcept is functioning correctly, testing it against</span>
  <span class="comment">// a type that satisfies MyConcept.</span>
  <span class="keyword">static_assert</span><span class="punct">(</span>sus::boxed::DynConcept<span class="punct">&lt;</span>DynMyConcept<span class="punct">,</span> MyConceptType<span class="punct">&gt;</span><span class="punct">)</span><span class="punct">;</span>

  <span class="keyword">auto</span> b <span class="punct">=</span> <span class="punct">[</span><span class="punct">]</span><span class="punct">(</span>Box<span class="punct">&lt;</span>DynMyConcept<span class="punct">&gt;</span> c<span class="punct">)</span> <span class="punct">{</span> c<span class="punct">-</span><span class="punct">&gt;</span>concept_fn<span class="punct">(</span><span class="punct">)</span><span class="punct">;</span> <span class="punct">}</span><span class="punct">;</span>
  <span class="comment">// `Box&lt;DynMyConcept&gt;` constructs from `MyConceptType`.</span>
  b<span class="punct">(</span>sus::into<span class="punct">(</span>MyConceptType<span class="punct">(</span><span class="punct">)</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span>

  <span class="keyword">auto</span> d <span class="punct">=</span> <span class="punct">[</span><span class="punct">]</span><span class="punct">(</span><span class="keyword">const</span> DynMyConcept<span class="punct">&amp;</span> c<span class="punct">)</span> <span class="punct">{</span> c<span class="punct">.</span>concept_fn<span class="punct">(</span><span class="punct">)</span><span class="punct">;</span> <span class="punct">}</span><span class="punct">;</span>
  <span class="comment">// `MyConceptType` converts to `const MyConcept&amp;` with `sus::dyn()`.</span>
  d<span class="punct">(</span>sus::dyn<span class="punct">&lt;</span><span class="keyword">const</span> DynMyConcept<span class="punct">&gt;</span><span class="punct">(</span>MyConceptType<span class="punct">(</span><span class="punct">)</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span>
<span class="punct">}</span>
</code></pre>
<p>An identical example to above, with a <code>DynMyConcept</code> class providing type
erasure for the <code>MyConcept</code> concept, however without the use of the helper
macros, showing all the required machinery:</p>
<pre><code><span class="comment">// A concept which requires a single const-access method named `concept_fn`.</span>
<span class="keyword">template</span> <span class="punct">&lt;</span><span class="keyword">class</span> T<span class="punct">&gt;</span>
<span class="keyword">concept</span> MyConcept <span class="punct">=</span> <span class="keyword">requires</span><span class="punct">(</span><span class="keyword">const</span> T<span class="punct">&amp;</span> t<span class="punct">)</span> <span class="punct">{</span>
  <span class="punct">{</span> t<span class="punct">.</span>concept_fn<span class="punct">(</span><span class="punct">)</span> <span class="punct">}</span> <span class="punct">-</span><span class="punct">&gt;</span> std::same_as<span class="punct">&lt;</span><span class="keyword">void</span><span class="punct">&gt;</span><span class="punct">;</span>
<span class="punct">}</span><span class="punct">;</span>

<span class="keyword">template</span> <span class="punct">&lt;</span><span class="keyword">class</span> T<span class="punct">,</span> <span class="keyword">class</span> Store<span class="punct">&gt;</span>
<span class="keyword">class</span> DynMyConceptTyped<span class="punct">;</span>

<span class="keyword">class</span> DynMyConcept <span class="punct">{</span>
 <span class="keyword">public</span>:
  <span class="comment">// Pure virtual concept API.</span>
  <span class="keyword">virtual</span> <span class="keyword">void</span> concept_fn<span class="punct">(</span><span class="punct">)</span> <span class="keyword">const</span> <span class="punct">=</span> 0<span class="punct">;</span>
  <span class="keyword">template</span> <span class="punct">&lt;</span><span class="keyword">class</span> T<span class="punct">&gt;</span>

  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> SatisfiesConcept <span class="punct">=</span> MyConcept<span class="punct">&lt;</span>T<span class="punct">&gt;</span><span class="punct">;</span>
  <span class="keyword">template</span> <span class="punct">&lt;</span><span class="keyword">class</span> T<span class="punct">,</span> <span class="keyword">class</span> Store<span class="punct">&gt;</span>
  <span class="keyword">using</span> DynTyped <span class="punct">=</span> DynMyConceptTyped<span class="punct">&lt;</span>T<span class="punct">,</span> Store<span class="punct">&gt;</span><span class="punct">;</span>

  DynMyConcept<span class="punct">(</span><span class="punct">)</span> <span class="punct">=</span> <span class="keyword">default</span><span class="punct">;</span>
  <span class="keyword">virtual</span> ~DynMyConcept<span class="punct">(</span><span class="punct">)</span> <span class="punct">=</span> <span class="keyword">default</span><span class="punct">;</span>
  DynMyConcept<span class="punct">(</span>DynC<span class="punct">&amp;</span><span class="punct">&amp;</span><span class="punct">)</span> <span class="punct">=</span> <span class="keyword">delete</span><span class="punct">;</span>
  DynMyConcept<span class="punct">&amp;</span> <span class="keyword">operator</span><span class="punct">=</span><span class="punct">(</span>DynMyConcept<span class="punct">&amp;</span><span class="punct">&amp;</span><span class="punct">)</span> <span class="punct">=</span> <span class="keyword">delete</span><span class="punct">;</span>
<span class="punct">}</span><span class="punct">;</span>
<span class="comment">// Verifies that DynMyConcept also satisfies MyConcept, which is required.</span>
<span class="keyword">static_assert</span><span class="punct">(</span>MyConcept<span class="punct">&lt;</span>DynMyConcept<span class="punct">&gt;</span><span class="punct">)</span><span class="punct">;</span>

<span class="keyword">template</span> <span class="punct">&lt;</span><span class="keyword">class</span> T<span class="punct">,</span> <span class="keyword">class</span> Store<span class="punct">&gt;</span>
<span class="keyword">class</span> DynMyConceptTyped final : <span class="keyword">public</span> DynMyConcept <span class="punct">{</span>
 <span class="keyword">public</span>:
  <span class="comment">// Virtual concept API implementation.</span>
  <span class="keyword">void</span> concept_fn<span class="punct">(</span><span class="punct">)</span> <span class="keyword">const</span> override <span class="punct">{</span> <span class="keyword">return</span> c_<span class="punct">.</span>concept_fn<span class="punct">(</span><span class="punct">)</span><span class="punct">;</span> <span class="punct">}</span><span class="punct">;</span>

  <span class="keyword">constexpr</span> DynMyConceptTyped<span class="punct">(</span>Store<span class="punct">&amp;</span><span class="punct">&amp;</span> c<span class="punct">)</span> : c_<span class="punct">(</span>::sus::forward<span class="punct">&lt;</span>Store<span class="punct">&gt;</span><span class="punct">(</span>c<span class="punct">)</span><span class="punct">)</span> <span class="punct">{</span><span class="punct">}</span>

 <span class="keyword">private</span>:
  Store c_<span class="punct">;</span>
<span class="punct">}</span><span class="punct">;</span>

<span class="comment">// A type which satiesfies `MyConcept`.</span>
<span class="keyword">struct</span> MyConceptType <span class="punct">{</span>
  <span class="keyword">void</span> concept_fn<span class="punct">(</span><span class="punct">)</span> <span class="keyword">const</span> <span class="punct">{</span><span class="punct">}</span>
<span class="punct">}</span><span class="punct">;</span>

<span class="keyword">int</span> main<span class="punct">(</span><span class="punct">)</span> <span class="punct">{</span>
  <span class="comment">// Verifies that DynMyConcept is functioning correctly, testing it against</span>
  <span class="comment">// a type that satisfies MyConcept.</span>
  <span class="keyword">static_assert</span><span class="punct">(</span>sus::boxed::DynConcept<span class="punct">&lt;</span>DynMyConcept<span class="punct">,</span> MyConceptType<span class="punct">&gt;</span><span class="punct">)</span><span class="punct">;</span>

  <span class="keyword">auto</span> b <span class="punct">=</span> <span class="punct">[</span><span class="punct">]</span><span class="punct">(</span>Box<span class="punct">&lt;</span>DynMyConcept<span class="punct">&gt;</span> c<span class="punct">)</span> <span class="punct">{</span> c<span class="punct">-</span><span class="punct">&gt;</span>concept_fn<span class="punct">(</span><span class="punct">)</span><span class="punct">;</span> <span class="punct">}</span><span class="punct">;</span>
  <span class="comment">// `Box&lt;DynMyConcept&gt;` constructs from `MyConceptType`.</span>
  b<span class="punct">(</span>sus::into<span class="punct">(</span>MyConceptType<span class="punct">(</span><span class="punct">)</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span>

  <span class="keyword">auto</span> d <span class="punct">=</span> <span class="punct">[</span><span class="punct">]</span><span class="punct">(</span><span class="keyword">const</span> DynMyConcept<span class="punct">&amp;</span> c<span class="punct">)</span> <span class="punct">{</span> c<span class="punct">.</span>concept_fn<span class="punct">(</span><span class="punct">)</span><span class="punct">;</span> <span class="punct">}</span><span class="punct">;</span>
  <span class="comment">// `MyConceptType` converts to `const MyConcept&amp;` with `sus::dyn()`.</span>
  d<span class="punct">(</span>sus::dyn<span class="punct">&lt;</span><span class="keyword">const</span> DynMyConcept<span class="punct">&gt;</span><span class="punct">(</span>MyConceptType<span class="punct">(</span><span class="punct">)</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span>
<span class="punct">}</span>
</code></pre>
<h2><a name="holding-dyn()-in-a-stack-variable" href="#holding-dyn()-in-a-stack-variable">Holding dyn() in a stack variable</a></h2>
<p>When a function receives a type-erased <code>DynC&amp;</code> by reference, it allows the
caller to avoid heap allocations should they wish. In the easy case, the
caller will simply call <code>sus::dyn()</code> directly in the function arguments to
construct the <code>DynC&amp;</code> reference, which ensures it outlives the function
call.</p>
<p>In a more complicated scenario, the caller may wish to conditionally decide
to pass an Option&lt;DynC&amp;&gt; with or without a reference, or to choose between
different references. It is not possible to return the result of
<code>sus::dyn()</code> without creating a dangling stack reference, which will be
caught by clang in most cases. This means in particular that lambdas such
as those passed to functions like <a href="sus-option-Option.html#method.map"><code>Option::map</code></a>
can not be used to construct the <code>DynC&amp;</code> reference.</p>
<p>In order to ensure the target of the <code>DynC&amp;</code> reference outlives the function
it can be constructed as a stack variable before calling the function.</p>
<pre><code>std::srand<span class="punct">(</span>sus::cast<span class="punct">&lt;</span><span class="keyword">unsigned</span><span class="punct">&gt;</span><span class="punct">(</span>std::time<span class="punct">(</span><span class="keyword">nullptr</span><span class="punct">)</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span>

<span class="keyword">auto</span> x <span class="punct">=</span> <span class="punct">[</span><span class="punct">]</span><span class="punct">(</span>sus::Option<span class="punct">&lt;</span>sus::fn::DynFn<span class="punct">&lt;</span>std::string<span class="punct">(</span><span class="punct">)</span><span class="punct">&gt;</span><span class="punct">&amp;</span><span class="punct">&gt;</span> fn<span class="punct">)</span> <span class="punct">{</span>
  <span class="keyword">if</span> <span class="punct">(</span>fn<span class="punct">.</span>is_some<span class="punct">(</span><span class="punct">)</span><span class="punct">)</span>
    <span class="keyword">return</span> sus::move<span class="punct">(</span>fn<span class="punct">)</span><span class="punct">.</span>unwrap<span class="punct">(</span><span class="punct">)</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span>
  <span class="keyword">else</span>
    <span class="keyword">return</span> std::string<span class="punct">(</span><span class="string">&quot;tails&quot;</span><span class="punct">)</span><span class="punct">;</span>
<span class="punct">}</span><span class="punct">;</span>

<span class="keyword">auto</span> heads <span class="punct">=</span> <span class="punct">[</span><span class="punct">]</span> <span class="punct">{</span> <span class="keyword">return</span> std::string<span class="punct">(</span><span class="string">&quot;heads&quot;</span><span class="punct">)</span><span class="punct">;</span> <span class="punct">}</span><span class="punct">;</span>
<span class="comment">// Type-erased `Fn&lt;std::string()&gt;` that represents `heads`. Placed on the</span>
<span class="comment">// stack to outlive its use in the `Option` and the call to `x(cb)`.</span>
<span class="keyword">auto</span> dyn_heads <span class="punct">=</span> sus::dyn<span class="punct">&lt;</span>sus::fn::DynFn<span class="punct">&lt;</span>std::string<span class="punct">(</span><span class="punct">)</span><span class="punct">&gt;</span><span class="punct">&gt;</span><span class="punct">(</span>heads<span class="punct">)</span><span class="punct">;</span>
<span class="comment">// Conditionally holds a type-erased reference to `heads`. This requires a</span>
<span class="comment">// type-erasure that outlives the `cb` variable.</span>
<span class="keyword">auto</span> cb <span class="punct">=</span> <span class="punct">[</span><span class="punct">&amp;</span><span class="punct">]</span><span class="punct">(</span><span class="punct">)</span> <span class="punct">-</span><span class="punct">&gt;</span> sus::Option<span class="punct">&lt;</span>sus::fn::DynFn<span class="punct">&lt;</span>std::string<span class="punct">(</span><span class="punct">)</span><span class="punct">&gt;</span><span class="punct">&amp;</span><span class="punct">&gt;</span> <span class="punct">{</span>
  <span class="keyword">if</span> <span class="punct">(</span>std::rand<span class="punct">(</span><span class="punct">)</span> <span class="punct">%</span> 2<span class="punct">)</span> <span class="keyword">return</span> sus::some<span class="punct">(</span>dyn_heads<span class="punct">)</span><span class="punct">;</span>
  <span class="keyword">return</span> sus::none<span class="punct">(</span><span class="punct">)</span><span class="punct">;</span>
<span class="punct">}</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span>

std::string s <span class="punct">=</span> x<span class="punct">(</span>cb<span class="punct">)</span><span class="punct">;</span>

fmt::println<span class="punct">(</span><span class="string">&quot;{}&quot;</span><span class="punct">,</span> s<span class="punct">)</span><span class="punct">;</span>  <span class="comment">// Prints one of &quot;heads&quot; or &quot;tails.</span>
</code></pre>
<p>It can greatly simplify correctness of code to use owned type-erased
concept objects through <a href="sus-boxed-Box.html"><code>Box</code></a>, such as
<code>Box&lt;DynFn&lt;std::string()&gt;&gt;</code> in the above example. Though references can be
useful, especially in simple or perf-critical code paths.</p>

            </div>
          </div>
        </div>
      </section>
    </main>
  </body>
</html>
