<!DOCTYPE html>
<html>
  <head>
    <meta name="generator" content="subdoc"></meta>
    <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
    <meta property="og:type" content="website"></meta>
    <meta property="og:site_name" content="Subspace"></meta>
    <title>sus::construct::cast - Subspace</title>
    <meta property="og:title" content="sus::construct::cast - Subspace"></meta>
    <meta name="description" content="An infallible conversion (cast) that may lose the original value in the process. If the input can not be represented in the output, some other value will be produced, which may lead to application bugs and memory unsafety if used incorrectly. This behaves like static_cast&lt;To&gt;() but without Undefined Behaviour."></meta>
    <meta property="og:description" content="An infallible conversion (cast) that may lose the original value in the process. If the input can not be represented in the output, some other value will be produced, which may lead to application bugs and memory unsafety if used incorrectly. This behaves like static_cast&lt;To&gt;() but without Undefined Behaviour."></meta>
    <script src="https://unpkg.com/lunr/lunr.js"></script>
    <script src="./search_db.js"></script>
    <script>
      
        // Delayed loading of whatever was in the search box.
        var searchDelayLoad;

        // The search box's dynamic behaviour.
        document.addEventListener("keyup", e => {
          if (e.key === 's') {
            document.querySelector('.search-input').focus();
          }
          if (e.key === 'Escape') {
            document.querySelector('.search-input').blur();
            navigateToSearch(null);
            e.preventDefault();
          }
        });
        function navigateToSearch(query) {
          window.clearTimeout(searchDelayLoad);
          searchDelayLoad = null;

          let without_search =
              window.location.origin + window.location.pathname;
          if (query) {
            window.history.replaceState(null, "",
              without_search + "?" + `search=${query}`);
          } else {
            window.history.replaceState(null, "", without_search);
          }
          maybeShowSearchResults();
        }
        addEventListener("load", event => {
          document.querySelector(".search-input").oninput = (e) => {
            window.clearTimeout(searchDelayLoad);
            searchDelayLoad = window.setTimeout(() => {
              navigateToSearch(e.target.value);
            }, 1000);
          };
          document.querySelector(".search-input").onkeypress = (e) => {
            if (e.key == "Enter") {
              navigateToSearch(e.target.value);
              e.preventDefault();
            }
          };
          var searchPlaceholder;
          document.querySelector(".search-input").onfocus = (e) => {
            searchPlaceholder = e.target.placeholder;
            e.target.placeholder = "Type your search here.";
            navigateToSearch(e.target.value);
          };
          document.querySelector(".search-input").onblur = (e) => {
            e.target.placeholder = searchPlaceholder;
            searchPlaceholder = null;
          };
        });

        // Show or hide any DOM element.
        function showHide(selector, show) {
          if (show)
            document.querySelector(selector).classList.remove("hidden");
          else
            document.querySelector(selector).classList.add("hidden");
        }

        function searchQuery() {
          const params = new Proxy(
            new URLSearchParams(window.location.search), {
              get: (searchParams, prop) => searchParams.get(prop),
            }
          );
          return params.search;
        }

        // Showing search results.
        async function populateSearchResults(loaded) {
          const search_db = loaded.search_db;
          const idx = loaded.idx;

          // lunrjs treats `:` specially and `::` breaks the query syntax, so
          // just split into two words.
          const query = searchQuery().split("::").join(" ");
          let content = '';
          try {
            const results = idx.search(query);
            for (r of results) {
              const item = search_db[r.ref];

              const type = item.type;
              const url = item.url;
              const name = item.name;
              const full_name = item.full_name;
              const summmary = item.summary ? item.summary : "";

              content += `\
                <a class="search-results-link" href="${url}">
                  <span class="search-results-type"><span>${type}</span></span>\
                  <span class="search-results-name"><span>${full_name}</span></span>\
                  <span class="search-results-summary"><span>${summmary}</span></span>\
                </a>\
                `
            }
          } catch (err) {
            content +=
                `<div class="search-error">Search error: ${err.message}</div>`;
          }

          let content_elem = document.querySelector(".search-results-content");
          content_elem.innerHTML = content;

          let header_elem = document.querySelector(".search-results-header");
          header_elem.innerText = "Search results";
        }

        var cache_idx;

        // Searching via https://lunrjs.com.
        //
        // Load the JSON search database, which will be turned into a search
        // index. Returns an object with two fields:
        // - search_db: the contents of the search.json file.
        // - idx: the lunr search index.
        //   Documented at https://lunrjs.com/docs/lunr.Index.html.
        async function loadSearchIndex() {
          // This is not widely supported yet (not on Safari), so instead we
          // turned the json file into a js file that sets a global variable. :|
          //async function load_search_db() {
          //  let x = await import('./search.json', {
          //    with: {type: 'json'}
          //  });
          //  return x.default;
          //}

          async function load_idx(search_db) {
            let idx = lunr(function () {
              this.ref('index');
              this.field('name', {
                'boost': 2
              });
              this.field('full_name', {
                'boost': 2
              });
              this.field('split_name', {
                'boost': 0.5
              });
              this.field('summary', {
                'boost': 1
              });
              this.field('full_description', {
                'boost': 0.75
              });

              // No stemming?
              // this.pipeline = new lunr.Pipeline();

              this.use(builder => {
                function splitColons(token) {
                  return token.toString().split("::").map(str => {
                    return token.clone().update(() => { return str })
                  })
                }
                lunr.Pipeline.registerFunction(splitColons, 'splitColons')
                builder.searchPipeline.before(lunr.stemmer, splitColons)
              });

              search_db.forEach(item => {
                this.add(item, {
                  'boost': item.weight ? Number(item.weight) : 1
                })
              }, this);
            });
            let out = {};
            out.search_db = search_db;
            out.idx = idx;
            return out;
          };

          if (!cache_idx) {
            cache_idx = await load_idx(g_search_db);
          }
          return cache_idx;
        }

        // If there's a search query, hide the other content and asynchronously
        // show the search results. Otherwise, hide search content and show the
        // rest immediately.
        function maybeShowSearchResults() {
          const query = searchQuery();
          if (query) {
            showHide(".main-content", false);

            let input = document.querySelector(".search-input");
            input.value = query;

            let header_elem = document.querySelector(".search-results-header");
            header_elem.innerText = "Loading search results...";

            let content_ele = document.querySelector(".search-results-content");
            content_ele.innerText = "";

            loadSearchIndex().then(populateSearchResults)
          } else {
            showHide(".main-content", true);

            let header_elem = document.querySelector(".search-results-header");
            header_elem.innerText = "";

            let content_ele = document.querySelector(".search-results-content");
            content_ele.innerText = "";
          }
        }

        
    </script>
    <link rel="stylesheet" href="subdoc-test-style.css">
    <link rel="icon" type="image/png" href="logo.png">
    <link rel="alternate icon" type="image/png" href="logo32.png">
    <link rel="alternate icon" type="image/png" href="logo16.png">
    <meta property="og:image" content="logo.png"></meta>
  </head>

  <body>
    <nav class="topbar">
      <button class="sidebar-menu-button" onclick="let e = document.getElementsByClassName('sidebar')[0];e.classList.toggle('shown');">
        ☰
      </button>
      <a class="topbar-logo-link" href="index.html"><div class="topbar-logo-border">
          <img class="topbar-logo" src="logo.png"></img>
        </div></a>
      <span class="topbar-text-area">
        <span class="topbar-title">
          <a href="#">cast</a>
        </span>
      </span>
    </nav>
    <nav class="sidebar">
      <a class="sidebar-logo-link" href="index.html"><div class="sidebar-logo-border">
          <img class="sidebar-logo" src="logo.png"></img>
        </div></a>
      <div class="sidebar-pretitle sidebar-text">
        function
      </div>
      <div class="sidebar-title sidebar-text">
        <a href="#">cast</a>
      </div>
      <div class="sidebar-subtitle sidebar-text">
      </div>
      <div class="sidebar-links sidebar-text">
        <ul>
        </ul>
      </div>
    </nav>
    <main>
      <nav class="search-nav">
        <form class="search-form">
          <input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press 'S' to search...">
          </input>
        </form>
      </nav>
      <section class="search-results">
        <h1 class="search-results-header">
        </h1>
        <div class="search-results-content">
        </div>
      </section>
      <section class="main-content">
        <script>maybeShowSearchResults()</script>
        <div class="function">
          <div class="section overview">
            <h1 class="section-header">
              <span>
                Function
              </span>
              <a class="project-name" href="index.html">Subspace</a>
              <span class="namespace-dots">::</span>
              <a class="namespace-name" href="namespace.sus.html">sus</a>
              <span class="namespace-dots">::</span>
              <a class="namespace-name" href="sus-namespace.construct.html">construct</a>
              <span class="namespace-dots">::</span>
              <a class="function-name" href="#">cast</a>
            </h1>
            <div class="overload-set">
              <div class="overload">
                <div class="function-signature"><div class="src rightside"><a href="https://github.com/chromium/subspace/blob/main/sus/construct/cast.h#L171">source</a></div><div class="template">template &lt;class To, class From&gt;</div><span class="function-auto">auto</span> <a class="function-name" href="#">cast</a>(<span class="const">const</span> From& from) -&gt; To<div class="requires">
                    <span class="requires-keyword keyword">
                      requires
                    </span>
                    <div class="requires-constraint"><pre class="requires-constraint-line">sus::construct::Cast&lt;To, From&gt;</pre></div>
                  </div></div>
              </div>
            </div>
            <div class="description long">
              <p>An infallible conversion (cast) that may lose the original
value in the process. If the input can not be represented in the output,
some other value will be produced, which may lead to application bugs and
memory unsafety if used incorrectly. This behaves like <code>static_cast&lt;To&gt;()</code>
but without Undefined Behaviour.</p>
<p>The <a href="sus-construct-fn.cast.html"><code>cast</code></a> operation is supported for types
<code>To</code> and <code>From</code> that satisfy <a href="sus-construct-Cast.html"><code>Cast&lt;To, From&gt;</code></a>.</p>
<p>Usually prefer to convert between types with the value-preserving methods
of <a href="sus-construct-From.html"><code>From</code></a> and
<a href="sus-construct-Into.html"><code>Into</code></a> and <a href="sus-construct-TryInto.html"><code>TryInto</code></a>
when possible. <a href="sus-construct-Cast.html"><code>Cast</code></a> is required for converting
from floating point to integer values, and from larger integer types to
floating point, as these are lossy conversions.</p>
<table>
<thead>
<tr>
<th>Concept</th>
<th>Usage</th>
<th>Infallible</th>
<th>Preserves values</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="sus-construct-From.html"><code>From</code></a> / <a href="sus-construct-Into.html"><code>Into</code></a></td>
<td><code>T::from(x)</code> / <a href="sus-construct-fn.into.html"><code>sus::into(x)</code></a></td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td><a href="sus-construct-TryFrom.html"><code>TryFrom</code></a> / <a href="sus-construct-TryInto.html"><code>TryInto</code></a></td>
<td><code>T::try_from(x)</code> / <a href="sus-construct-fn.try_into.html"><code>sus::try_into&lt;T&gt;(x)</code></a></td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td><a href="sus-construct-Cast.html"><code>Cast</code></a></td>
<td><code>sus::cast&lt;T&gt;(x)</code></td>
<td>✅</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p>See <a href="sus-construct-Cast.html"><code>Cast</code></a> for how numeric and
primitive values are converted.</p>
<p>It is best practice to place a <code>// SAFETY:</code> comment on use of <a href="sus-construct-fn.cast.html"><code>sus::cast</code></a> in order to explain why the code intends to change
the value during the cast.</p>
<h1><a name="examples" href="#examples">Examples</a></h1>
<p>This converts <code>-1_i64</code> into a <code>u32</code>, which both changes its meaning,
becoming a large positive number, and truncates the high 32 bits, losing the
original bits.</p>
<pre><code class="language-cpp"><span class="comment">// SAFETY: We're intending to convert negative numbers into large positive</span>
<span class="comment">// values for this example.</span>
sus_check<span class="punct">(</span>u32::MAX <span class="punct">=</span><span class="punct">=</span> sus::cast<span class="punct">&lt;</span>u32<span class="punct">&gt;</span><span class="punct">(</span><span class="punct">-</span>1_i64<span class="punct">)</span><span class="punct">)</span><span class="punct">;</span>
</code></pre>

            </div>
          </div>
        </div>
      </section>
    </main>
  </body>
</html>
